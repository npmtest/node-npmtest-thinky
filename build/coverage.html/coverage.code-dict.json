{"/home/travis/build/npmtest/node-npmtest-thinky/test.js":"/* istanbul instrument in package npmtest_thinky */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-thinky/lib.npmtest_thinky.js":"/* istanbul instrument in package npmtest_thinky */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_thinky = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_thinky = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-thinky/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-thinky && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_thinky */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_thinky\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_thinky.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_thinky.rollup.js'] =\n            local.assetsDict['/assets.npmtest_thinky.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_thinky.__dirname +\n                    '/lib.npmtest_thinky.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/thinky.js":"var rethinkdbdash = require('rethinkdbdash');\nvar Promise = require('bluebird');\nvar Model = require(__dirname+'/model.js');\nvar util = require(__dirname+'/util.js');\nvar type = require(__dirname+'/type/index.js');\nvar Query = require(__dirname+'/query.js');\nvar Errors = require(__dirname+'/errors.js');\n\n/**\n * Main method, create the default database.\n *\n * @param {Object} options the options for the driver and the future models created.\n *  - `max` {number} The maximum number of connections in the pool, default 1000\n *  - `buffer` {number} The minimum number of connections available in the pool, default 50\n *  - `timeoutError` {number} The wait time before reconnecting in case of an error (in ms), default 1000\n *  - `timeoutGb` {number} How long the pool keep a connection that hasn't been used (in ms), default 60*60*1000\n *  - `enforce_missing` {boolean}, default `false`\n *  - `enforce_extra` {\"strict\"|\"remove\"|\"none\"}, default `\"none\"`\n *  - `enforce_type` {\"strict\"|\"loose\"|\"none\"}, default `\"loose\"`\n *  - `timeFormat` {\"raw\"|\"native\"}\n *  - `createDatabase` {boolean} Whether thinky should create the database or not.\n */\nfunction Thinky(config) {\n  var self = this;\n\n  config = config || {};\n  config.db = config.db || 'test'; // We need the default db to create it.\n  self._config = config;\n\n  self._options = {};\n  // Option passed to each model we are going to create.\n  self._options.enforce_missing =\n    (config.enforce_missing != null) ? config.enforce_missing : false;\n  self._options.enforce_extra =\n    (config.enforce_extra != null) ? config.enforce_extra : \"none\";\n  self._options.enforce_type =\n    (config.enforce_type != null) ? config.enforce_type : 'loose';\n\n  // Format of time objects returned by the database, by default we convert\n  // them to JavaScript Dates.\n  self._options.timeFormat =\n    (config.timeFormat != null) ? config.timeFormat : 'native';\n  // Option passed to each model we are going to create.\n  self._options.validate =\n    (config.validate != null) ? config.validate : 'onsave';\n\n  if (config.r === undefined) {\n    self.r = rethinkdbdash(config);\n  }\n  else {\n    self.r = config.r;\n  }\n  self.type = type;\n  self.Query = Query;\n  self.models = {};\n\n  // Export errors\n  self.Errors = Errors;\n\n  // Initialize the database.\n  self.dbReady().then().error(function(error) {\n    throw error;\n  });\n}\n\n\n/**\n * Initialize our database.\n * @return {Promise=} Returns a promise which will resolve when the database is ready.\n */\nThinky.prototype.dbReady = function() {\n  var self = this;\n  if (this._dbReadyPromise) return this._dbReadyPromise;\n  var r = self.r;\n  if (self._config.createDatabase === false) {\n    return Promise.resolve();\n  }\n  this._dbReadyPromise = r.dbCreate(self._config.db)\n  .run()\n  .error(function(error) {\n    // The `do` is not atomic, we a concurrent query could create the database\n    // between the time `dbList` is ran and `dbCreate` is.\n    if (error.message.match(/^Database `.*` already exists in/)) {\n      return;\n    }\n\n    // In case something went wrong here, we do not recover and throw.\n    throw error;\n  });\n\n  return self._dbReadyPromise;\n};\n\n/**\n * Return the current option used.\n * @return {object} The global options of the library\n */\nThinky.prototype.getOptions = function() {\n  return this._options;\n}\n\n\n/**\n * Create a model\n *\n * @param {string} name The name of the table used behind this model.\n * @param {object|Type} schema The schema of this model.\n * @param {object=} options Options for this model. The fields can be:\n *  - `init` {boolean} Whether the table should be created or not. The value\n *  `false` is used to speed up testing, and should probably be `true` in\n *  other use cases.\n *  - `timeFormat` {\"raw\"|\"native\"} Format of ReQL dates.\n *  - `enforce_missing` {boolean}, default `false`.\n *  - `enforce_extra` {\"strict\"|\"remove\"|\"none\"}, default `\"none\"`.\n *  - `enforce_type` {\"strict\"|\"loose\"|\"none\"}, default `\"loose\"`.\n *  - `validate` {\"oncreate\"|\"onsave\"}, default \"onsave\".\n */\nThinky.prototype.createModel = function(name, schema, options) {\n  var self = this;\n\n  // Make a deep copy of the options as the model may overwrite them.\n  var fullOptions = util.deepCopy(this._options);\n  options = options || {};\n  util.loopKeys(options, function(options, key) {\n    fullOptions[key] = options[key];\n  });\n\n  // Two models cannot share the same name.\n  if (self.models[name] !== undefined) {\n    throw new Error(\"Cannot redefine a Model\");\n  }\n\n  // Create the constructor returned. This will also validate the schema.\n  var model = Model.new(name, schema, fullOptions, self);\n\n  // Keep a reference of this model.\n  self.models[name] = model;\n  return model;\n}\n\n\n/**\n * Method to clean all the references to the models. This is used to speed up\n * testing and should not be used in other use cases.\n */\nThinky.prototype._clean = function() {\n  this.models = {};\n}\n\n\n// Export the module.\nmodule.exports = function(config) {\n  return new Thinky(config);\n}\n\n// Expose thinky types directly from module\nmodule.exports.type = type;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/model.js":"var util = require(__dirname+'/util.js');\nvar _util = require('util');\nvar schemaUtil = require(__dirname+'/schema.js');\nvar Document = require(__dirname+'/document.js');\nvar EventEmitter = require('events').EventEmitter;\nvar Query = require(__dirname+'/query.js');\nvar Promise = require('bluebird');\nvar Errors = require(__dirname+'/errors.js');\n\n/*\n * Constructor for a Model. Note that this is not what `thinky.createModel`\n * returns. It is the prototype of what `thinky.createModel` returns.\n * The whole chain being:\n * document.__proto__ = new Document(...)\n * document.__proto__.constructor = model (returned by thinky.createModel\n * document.__proto__._model = instance of Model\n * document.__proto__.constructor.__proto__ = document.__proto__._model\n */\nfunction Model(name, schema, options, thinky) {\n  /**\n   * Name of the table used\n   * @type {string}\n   */\n  this._name = name;\n\n  // We want a deep copy\n  options = options || {};\n  this._options = {};\n  this._options.enforce_missing = (options.enforce_missing != null) ? options.enforce_missing : thinky._options.enforce_missing;\n  this._options.enforce_extra = (options.enforce_extra != null) ? options.enforce_extra : thinky._options.enforce_extra;\n  this._options.enforce_type = (options.enforce_type != null) ? options.enforce_type : thinky._options.enforce_type;\n  this._options.timeFormat = (options.timeFormat != null) ? options.timeFormat : thinky._options.timeFormat;\n  this._options.validate = (options.validate != null) ? options.validate : thinky._options.validate;\n\n  this._schema = schemaUtil.parse(schema, '', this._options, this);\n  //console.log(JSON.stringify(this._schema, null, 2));\n\n  this.virtualFields = [];\n  this.defaultFields = [];\n  this._schema._getDefaultFields([], this.defaultFields, this.virtualFields)\n\n  this.needToGenerateFields = (this.defaultFields.length+this.virtualFields.length) !== 0;\n\n  this._pk = (options.pk != null) ? options.pk : 'id';\n\n  this._table = (options.table != null) ? options.table : {};\n  this._table.primaryKey = this._pk;\n\n  this._thinky = thinky;\n\n  this._validator = options.validator;\n\n  this._indexes = {}; // indexName -> true\n  this._pendingPromises = [];\n\n  this._error = null; // If an error occured, we won't let people save things\n\n  this._listeners = {};\n  this._maxListeners = 10;\n  this._joins = {};\n  this._localKeys = {}; // key used as a foreign key by another model\n\n  // This is to track joins that were not directly called by this model but that we still need\n  // to purge the database\n  this._reverseJoins = {};\n\n  this._methods = {};\n  this._staticMethods = {};\n  this._async = {\n    init: false,\n    retrieve: false,\n    save: false,\n    validate: false\n  };\n\n  this._pre = {\n    save: [],\n    delete: [],\n    validate: []\n  };\n  this._post = {\n    init: [],\n    retrieve: [],\n    save: [],\n    delete: [],\n    validate: []\n  };\n}\n_util.inherits(Model, EventEmitter);\n\nModel.new = function(name, schema, options, thinky) {\n\n  var proto = new Model(name, schema, options, thinky);\n  proto._initModel = options.init  !== undefined ? !!options.init : true;\n\n  var model = function model(doc, options) {\n    if (!util.isPlainObject(doc)) {\n      throw new Error(\"Cannot build a new instance of `\"+proto._name+\"` without an object\")\n    }\n    // We create a deepcopy only if doc was already used to create a document\n    if (doc instanceof Document) {\n      doc = util.deepCopy(doc);\n    }\n\n    util.changeProto(doc, new Document(model, options));\n\n    // Create joins document. We do it here because `options` are easily available\n    util.loopKeys(proto._joins, function(joins, key) {\n      if (doc[key] != null) {\n        if ((joins[key].type === 'hasOne') && (doc[key] instanceof Document === false)) {\n          doc[key] = new joins[key].model(doc[key], options);\n        }\n        else if ((joins[key].type === 'belongsTo') && (doc[key] instanceof Document === false)) {\n          doc[key] = new joins[key].model(doc[key], options);\n        }\n        else if (joins[key].type === 'hasMany') {\n          doc.__proto__._hasMany[key] = []\n\n          for(var i=0; i<doc[key].length; i++) {\n            if (doc[key][i] instanceof Document === false) {\n              doc[key][i] = new joins[key].model(doc[key][i], options);\n            }\n          }\n        }\n        else if (joins[key].type === 'hasAndBelongsToMany') {\n          for(var i=0; i<doc[key].length; i++) {\n            if (doc[key][i] instanceof Document === false) {\n              doc[key][i] = new joins[key].model(doc[key][i], options);\n            }\n          }\n        }\n      }\n    });\n    doc._getModel()._schema._setModel(doc._getModel());\n    if (proto.needToGenerateFields === true) {\n      doc._generateDefault();\n    }\n\n    var promises = [];\n    var promise;\n    if (proto._options.validate === 'oncreate') {\n      promise = doc.validate(options);\n      if (promise instanceof Promise) promises.push(promise);\n    }\n\n    if (proto._post.init.length > 0) {\n      promise = util.hook({\n        postHooks: doc._getModel()._post.init,\n        doc: doc,\n        async: doc._getModel()._async.init,\n        fn: function() {\n          return doc;\n        }\n      })\n      if (promise instanceof Promise) promises.push(promise);\n    }\n\n    if (promises.length > 0) {\n      return Promise.all(promises).then(function(docs) {\n        return docs[0];\n      });\n    }\n    return doc;\n  }\n\n  model.__proto__ = proto;\n\n  if (options.init !== false) {\n    // Setup the model's table.\n    model.tableReady().then();\n  }\n  else {\n    // We do not initialize the table and suppose that it already exists and\n    // is ready.\n    model.emit('created');\n    model.emit('ready');\n  }\n\n  // So people can directly call the EventEmitter from the constructor\n  // TOIMPROVE: We should emit everything from the constructor instead of emitting things from\n  // the constructor and the instance of Model\n  util.loopKeys(EventEmitter.prototype, function(emitter, key) {\n    (function(_key) {\n      model[_key] = function() {\n        model._getModel()[_key].apply(model._getModel(), arguments);\n      }\n    })(key)\n  });\n\n\n  return model\n}\n\n/**\n * Create the model's table.\n * @return {Promise=} Returns a promise which will resolve when the table is ready.\n */\nModel.prototype.tableReady = function() {\n  var self = this;\n  var model = this._getModel();\n  if (!this._initModel) return Promise.resolve();\n  if (this._tableReadyPromise) return this._tableReadyPromise;\n\n  // Create the table, or push the table name in the queue.\n  var r = model._thinky.r;\n  this._tableReadyPromise = model._thinky.dbReady()\n  .then(function() {\n    return r.tableCreate(model._name, model._table).run();\n  })\n  .error(function(error) {\n    if (error.message.match(/Table `.*` already exists/)) {\n      return;\n    }\n    model._error = error;\n    // Should we throw here?\n  });\n\n  return this._tableReadyPromise.then(function() {\n    self.emit('created');\n    if (!self._pendingPromises.length) {\n      self.emit('ready');\n    }\n  });\n};\n\n/**\n * Get a promise which resolves when the Model's table and\n * all indices have been created.\n */\nModel.prototype.ready = function() {\n  var requirements = [];\n\n  // Ensure the Model's table is ready\n  requirements.push(this.tableReady());\n\n  // Ensure all other pending promises have been resolved\n  requirements.push(this._promisesReady());\n\n  return Promise.all(requirements);\n};\n\nModel.prototype._promisesReady = function() {\n  var self = this;\n  if (this._promisesReadyPromise) return this._promisesReadyPromise;\n\n  var verifyAll = function() {\n    return Promise.all(self._pendingPromises)\n    .then(function() {\n      var i, allFullfilled = true;\n      for (i=0; i<self._pendingPromises.length; i++) {\n         if (!self._pendingPromises[i].isFulfilled()) {\n          allFullfilled = false;\n          break;\n         }\n      }\n      return allFullfilled ? Promise.resolve() : verifyAll();\n    });\n  };\n\n  this._promisesReadyPromise = verifyAll();\n  return this._promisesReadyPromise;\n};\n\nModel.prototype._waitFor = function(promise) {\n  var self = this;\n  this._pendingPromises.push(promise);\n\n  // Emit 'ready' when all pending promises have resolved\n  if (!this._pendingReady) {\n    this._pendingReady = this._promisesReady().then(function() {\n      delete self._pendingReady;\n      self.emit('ready', self);\n    });\n  }\n};\n\n\nModel.prototype._setError = function(error) {\n  this._getModel()._error = error;\n  this.emit('error', error);\n}\n\n\n/*\n * Return the options of the model -- call from an instance of Model\n */\nModel.prototype.getOptions = function() {\n  return this._options;\n}\n\n\n/*\n * Return the instance of Model **when called on the function**\n */\nModel.prototype._getModel = function() {\n  return this.__proto__;\n}\n\n/*\n * Return the instance of Model\n */\nModel.prototype.getTableName = function() {\n  return this._getModel()._name;\n}\n\n\nModel.prototype.ensureIndex = function(name, fn, opts) {\n  var self = this;\n\n  if ((opts === undefined) && (util.isPlainObject(fn))) {\n    opts = fn;\n    fn = undefined;\n  }\n\n  return self._createIndex(name, fn, opts)\n  .catch(function(error) {\n    self._getModel()._setError(error);\n    throw error;\n  });\n}\n\nModel.prototype._createIndex = function(name, fn, opts) {\n  var model = this._getModel();\n  var tableName = this.getTableName();\n  var r = model._thinky.r;\n\n  if (opts === undefined && util.isPlainObject(fn)) {\n    opts = fn;\n    fn = undefined;\n  }\n\n  var promise = this.tableReady().then(function() {\n    return new Promise(function(resolve, reject) {\n      return r.branch(\n        r.table(tableName).indexList().contains(name),\n        r.table(tableName).indexWait(name),\n        r.branch(\n          r.table(tableName).info()('primary_key').eq(name),\n          r.table(tableName).indexWait(name),\n          r.table(tableName).indexCreate(name, fn, opts).do(function() {\n            return r.table(tableName).indexWait(name);\n          })\n        )\n      )\n      .run()\n      .then(resolve)\n      .error(function(error) {\n        if (error.message.match(/^Index/)) {\n          // TODO: This regex seems a bit too generous since messages such\n          // as \"Index `id` was not found on table...\" will be accepted.\n          // Figure out if this is OK or not.\n          return resolve();\n        }\n        reject(error);\n      });\n    });\n  })\n  .then(function() {\n    model._indexes[name] = true;\n  });\n\n  this._waitFor(promise);\n  return promise;\n};\n\n/*\n * joinedModel: the joined model\n * fieldDoc: the field where the joined document will be kept\n * leftKey: the key in the model used for the join\n * rightKey: the key in the joined model used for the join\n *\n * The foreign key is stores in the joinedModel\n *\n * Post.hasOne(Author, \"author\", \"id\", \"postId\"\n *                ^- post.id\n *\n * options can be:\n * - init: Boolean (create an index or not)\n * - timeFormat: 'raw'/'native'\n * - enforce_extra: 'strict'/'remove'/'none'\n * - enforce_missing: Boolean\n * - enforce_type: 'strict'/'loose'/'none'\n * - validate: 'oncreate'/'onsave'\n */\nModel.prototype.hasOne = function(joinedModel, fieldDoc, leftKey, rightKey, options) {\n  var self  = this;\n\n  if ((joinedModel instanceof Model) === false) {\n    throw new Error(\"First argument of `hasOne` must be a Model\")\n  }\n  if (fieldDoc in self._getModel()._joins) {\n    throw new Error(\"The field `\"+fieldDoc+\"` is already used by another relation.\");\n  }\n  if (fieldDoc === \"_apply\") {\n    throw new Error(\"The field `_apply` is reserved by thinky. Please use another one.\");\n  }\n  self._getModel()._joins[fieldDoc] = {\n    model: joinedModel,\n    leftKey: leftKey,\n    rightKey: rightKey,\n    type: 'hasOne'\n  }\n  joinedModel._getModel()._localKeys[rightKey] = true;\n\n  options = options || {};\n  if (options.init !== false) {\n    var newIndex = joinedModel._createIndex(rightKey)\n    .catch(function(error) {\n      joinedModel._getModel()._setError(error);\n      self._getModel()._setError(error);\n    });\n    self._waitFor(newIndex);\n  }\n}\n\n/*\n * joinedModel: the joined model\n * fieldDoc: the field where the joined document will be kept\n * leftKey: the key in the model used for the join\n * rightKey: the key in the joined model used for the join\n *\n * The foreign key is store in the model calling belongsTo\n *\n * Post.belongsTo(Author, \"author\", \"authorId\", \"id\"\n *                        ^- author.id\n */\nModel.prototype.belongsTo = function(joinedModel, fieldDoc, leftKey, rightKey, options) {\n  var self  = this;\n\n  if ((joinedModel instanceof Model) === false) {\n    throw new Error(\"First argument of `belongsTo` must be a Model\")\n  }\n  if (fieldDoc in self._getModel()._joins) {\n    throw new Error(\"The field `\"+fieldDoc+\"` is already used by another relation.\");\n  }\n  if (fieldDoc === \"_apply\") {\n    throw new Error(\"The field `_apply` is reserved by thinky. Please use another one.\");\n  }\n\n  self._getModel()._joins[fieldDoc] = {\n    model: joinedModel,\n    leftKey: leftKey,\n    rightKey: rightKey,\n    type: 'belongsTo'\n  };\n  self._getModel()._localKeys[leftKey] = true;\n\n  joinedModel._getModel()._reverseJoins[fieldDoc] = {\n    model: self,\n    leftKey: leftKey,\n    rightKey: rightKey,\n    type: 'belongsTo',\n  }\n\n  options = options || {};\n  if (options.init !== false) {\n    /*\n    var newIndex = self._createIndex(leftKey)\n    .catch(function(error) {\n      joinedModel._getModel()._setError(error);\n      self._getModel()._setError(error);\n    });\n    joinedModel._waitFor(newIndex);\n    */\n    var newIndex = joinedModel._createIndex(rightKey)\n    .catch(function(error) {\n      joinedModel._getModel()._setError(error);\n      self._getModel()._setError(error);\n    });\n    self._waitFor(newIndex);\n\n  }\n}\n\n\n/*\n * joinedModel: the joined model\n * fieldDoc: the field where the joined document will be kept\n * leftKey: the key in the model used for the join\n * rightKey: the key in the joined model used for the join\n *\n * A post has one author, and an author can write multiple posts\n * Author.hasMany(Post, \"posts\", \"id\", \"authorId\"\n *                 ^- author.id\n */\nModel.prototype.hasMany = function(joinedModel, fieldDoc, leftKey, rightKey, options) {\n  var self  = this;\n\n  if ((joinedModel instanceof Model) === false) {\n    throw new Error(\"First argument of `hasMany` must be a Model\")\n  }\n  if (fieldDoc in self._getModel()._joins) {\n    throw new Error(\"The field `\"+fieldDoc+\"` is already used by another relation.\");\n  }\n  if (fieldDoc === \"_apply\") {\n    throw new Error(\"The field `_apply` is reserved by thinky. Please use another one.\");\n  }\n\n  this._getModel()._joins[fieldDoc] = {\n    model: joinedModel,\n    leftKey: leftKey,\n    rightKey: rightKey,\n    type: 'hasMany'\n  };\n  joinedModel._getModel()._localKeys[rightKey] = true;\n\n  options = options || {};\n  if (options.init !== false) {\n    var newIndex = joinedModel._createIndex(rightKey)\n    .catch(function(error) {\n      self._getModel()._setError(error);\n      joinedModel._getModel()._setError(error);\n    });\n    self._waitFor(newIndex);\n  }\n}\n\n\n/*\n * joinedModel: the joined model\n * fieldDoc: the field where the joined document will be kept\n * leftKey: the key in the model used for the join\n * rightKey: the key in the joined model used for the join\n *\n * Patient.hasAndBelongsToMany(Doctor, \"doctors\", \"id\", \"id\"\n *                     patient.id-^  ^-doctor.id\n *\n * It automatically creates a table <modelName>_<joinedModel> or <joinedModel>_<modelName> (alphabetic order)\n */\nModel.prototype.hasAndBelongsToMany = function(joinedModel, fieldDoc, leftKey, rightKey, options) {\n  var self = this;\n  var link, query;\n  var thinky = this._getModel()._thinky;\n  options = options || {};\n\n  if ((joinedModel instanceof Model) === false) {\n    throw new Error(\"First argument of `hasAndBelongsToMany` must be a Model\")\n  }\n  if (fieldDoc in self._getModel()._joins) {\n    throw new Error(\"The field `\"+fieldDoc+\"` is already used by another relation.\");\n  }\n  if (fieldDoc === \"_apply\") {\n    throw new Error(\"The field `_apply` is reserved by thinky. Please use another one.\");\n  }\n\n  if (this._getModel()._name < joinedModel._getModel()._name) {\n    link = this._getModel()._name+\"_\"+joinedModel._getModel()._name;\n  }\n  else {\n    link = joinedModel._getModel()._name+\"_\"+this._getModel()._name;\n  }\n  if (typeof options.type === 'string') {\n    link = link+\"_\"+options.type;\n  }\n  else if (typeof options.type !== 'undefined') {\n    throw new Error('options.type should be a string or undefined.')\n  }\n\n  var linkModel;\n  if (thinky.models[link] === undefined) {\n    // Create a model, claim the namespace and create the table\n    // passes table options to the underlying model (e.g. replicas, shards)\n    linkModel = thinky.createModel(link, {}, { table: options.table });\n  }\n  else {\n    linkModel = thinky.models[link];\n  }\n\n\n  this._getModel()._joins[fieldDoc] = {\n    model: joinedModel,\n    leftKey: leftKey,\n    rightKey: rightKey,\n    type: 'hasAndBelongsToMany',\n    link: link,\n    linkModel: linkModel\n  }\n\n  joinedModel._getModel()._reverseJoins[self.getTableName()] = {\n    leftKey: leftKey,\n    rightKey: rightKey,\n    type: 'hasAndBelongsToMany',\n    link: link,\n    linkModel: linkModel\n  }\n\n  if (options.init !== false) {\n    var r = self._getModel()._thinky.r;\n\n    var query;\n    if ((this.getTableName() === joinedModel.getTableName())\n      && (leftKey === rightKey)) {\n      // The relation is built for the same model, using the same key\n      // Create a multi index\n      query = r.branch(\n        r.table(link).indexList().contains(leftKey+\"_\"+rightKey),\n        r.table(link).indexWait(leftKey+\"_\"+rightKey),\n        r.table(link).indexCreate(leftKey+\"_\"+rightKey, function(doc) {\n          return doc(leftKey+\"_\"+rightKey)\n        }, {multi: true}).do(function() {\n          return r.table(link).indexWait(leftKey+\"_\"+rightKey)\n        })\n      )\n    }\n    else {\n      query = r.branch(\n        r.table(link).indexList().contains(self.getTableName()+'_'+leftKey),\n        r.table(link).indexWait(self.getTableName()+'_'+leftKey),\n        r.table(link).indexCreate(self.getTableName()+'_'+leftKey).do(function() {\n          return r.table(link).indexWait(self.getTableName()+'_'+leftKey)\n        })\n      ).do(function() {\n        return r.branch(\n          r.table(link).indexList().contains(joinedModel.getTableName()+'_'+rightKey),\n          r.table(link).indexWait(joinedModel.getTableName()+'_'+rightKey),\n          r.table(link).indexCreate(joinedModel.getTableName()+'_'+rightKey).do(function() {\n            return r.table(link).indexWait(joinedModel.getTableName()+'_'+rightKey)\n          })\n        )\n      })\n\n    }\n\n    var linkPromise = linkModel.ready().then(function() {\n      return query.run()\n      .then(function() {\n        self._getModel()._indexes[leftKey] = true;\n        joinedModel._getModel()._indexes[rightKey] = true;\n      })\n      .error(function(error) {\n        if (error.message.match(/^Index `/)) {\n          return;\n        }\n        if (error.message.match(/^Table `.*` already exists/)) {\n          return;\n        }\n        self._getModel()._setError(error);\n        joinedModel._getModel()._setError(error);\n        throw error;\n      });\n    })\n    .then(function() {\n      self._createIndex(leftKey)\n      .catch(function(error) {\n        self._getModel()._setError(error);\n        joinedModel._getModel()._setError(error);\n      });\n\n      joinedModel._createIndex(rightKey)\n      .catch(function(error) {\n        self._getModel()._setError(error);\n        joinedModel._getModel()._setError(error);\n      });\n    });\n\n    joinedModel._waitFor(linkPromise);\n    self._waitFor(linkPromise);\n\n    return Promise.all([self.ready(), joinedModel.ready()]);\n  }\n};\n\n(function() {\n  // Import rethinkdbdash methods\n  var Term = require('rethinkdbdash')({pool: false}).expr(1).__proto__;\n  util.loopKeys(Term, function(Term, key) {\n    if (!Term.hasOwnProperty(key)) return;\n    if (key === 'run' || key[0] === '_') return;\n\n    (function(key) {\n      switch (key) {\n        case 'orderBy':\n          Model.prototype[key] = function() {\n            var query = new Query(this);\n            if ((arguments.length === 1)\n              && (typeof arguments[0] === 'string')\n              && (this._getModel()._indexes[arguments[0]] === true)) {\n\n                query = query[key]({index: arguments[0]});\n                return query;\n            }\n            else {\n              query = query[key].apply(query, arguments);\n              return query;\n            }\n          }\n          break;\n        case 'filter':\n          Model.prototype[key] = function() {\n            var query = new Query(this);\n            if ((arguments.length === 1)\n              && (util.isPlainObject(arguments[0]))) {\n\n              // Optimize a filter with an object\n              // We replace the first key that match an index name\n              var filter = arguments[0];\n\n              var keys = Object.keys(filter).sort(); // Lexicographical order\n              for(var i=0 ; i<keys.length; i++) {\n                var index = keys[i];\n\n                if (this._getModel()._indexes[index] === true) { // Index found\n                  query = query.getAll(filter[index], {index: index});\n                  delete filter[index];\n                  break;\n                }\n              }\n            }\n\n            query = query[key].apply(query, arguments);\n            return query;\n          }\n          break;\n        case 'get':\n          // Make a copy of `get` into `_get`\n          Model.prototype['_get'] = function() {\n            var query = new Query(this);\n            query = query['_get'].apply(query, arguments);\n            return query;\n          }\n        default:\n          Model.prototype[key] = function() {\n            var query = new Query(this);\n            query = query[key].apply(query, arguments);\n            return query;\n          }\n      }\n\n    })(key);\n  });\n})();\n\nModel.prototype.getJoin = function() {\n  var query = new Query(this);\n  return query.getJoin.apply(query, arguments)\n}\n\nModel.prototype.removeRelations = function(relationsToRemove) {\n  var query = new Query(this);\n  return query.removeRelations(relationsToRemove);\n}\n\n\nModel.prototype.run = function(options) {\n  var query = new Query(this);\n  return query.run(options);\n}\nModel.prototype.execute = function(options) {\n  var query = new Query(this);\n  return query.execute(options);\n}\n\nModel.prototype.save = function(docs, options) {\n  var self = this;\n  var r = self._getModel()._thinky.r;\n  var isArray = Array.isArray(docs);\n\n  if (!isArray) {\n    docs = [docs];\n  }\n\n  var p = new Promise(function(mainResolve, mainReject) {\n    var toSave = docs.length;\n\n    var resolves = [];\n    var rejects = [];\n    var executeInsert = function (resolve, reject) {\n      toSave--;\n      resolves.push(resolve);\n      rejects.push(reject);\n\n      if (toSave === 0) {\n        var copies = [];\n        for(var i=0; i<docs.length; i++) {\n          copies.push(docs[i]._makeSavableCopy());\n        }\n        var _options;\n        if (util.isPlainObject(options)) {\n          _options = util.deepCopy(options);\n        }\n        else {\n          _options = {};\n        }\n        _options.returnChanges = 'always';\n        r.table(self.getTableName()).insert(copies, _options).run().then(function(results) {\n          if (results.errors === 0) {\n            // results.changes currently does not enforce the same order as docs\n            if (Array.isArray(results.changes)) {\n              for(var i=0; i<results.changes.length; i++) {\n                docs[i]._merge(results.changes[i].new_val);\n                if (docs[i]._getModel().needToGenerateFields === true) {\n                  docs[i]._generateDefault();\n                }\n                docs[i]._setOldValue(util.deepCopy(results.changes[i].old_val));\n                docs[i].setSaved();\n                docs[i].emit('saved', docs[i]);\n              }\n            }\n            for(i=0; i<resolves.length; i++) {\n              resolves[i]();\n            }\n          }\n          else {\n            //TODO Expand error with more information\n            for(var i=0; i<rejects.length; i++) {\n              rejects[i](new Error(\"An error occurred during the batch insert. Original results:\\n\"+JSON.stringify(results, null, 2)));\n            }\n          }\n        }).error(reject);\n      }\n    };\n\n    var promises = [];\n    var foundNonValidDoc = false;\n    for(var i=0; i<docs.length; i++) {\n      if (foundNonValidDoc === true) {\n        return;\n      }\n      if (docs[i] instanceof Document === false) {\n        docs[i] = new self(docs[i]);\n      }\n      var promise;\n      util.tryCatch(function() {\n        promise = docs[i].validate();\n        if (promise instanceof Promise) {\n          promises.push(promise)\n        }\n      }, function(error) {\n        foundNonValidDoc = true;\n        mainReject(new Errors.ValidationError(\"One of the documents is not valid. Original error:\\n\"+error.message))\n      });\n    }\n\n    if (foundNonValidDoc === false) {\n      Promise.all(promises).then(function() {\n        var promises = [];\n        for(var i=0; i<docs.length; i++) {\n          promises.push(docs[i]._batchSave(executeInsert));\n        }\n        Promise.all(promises).then(function() {\n          mainResolve(docs);\n        }).error(function(error) {\n          mainReject(error)\n        });\n      }).error(function(error) {\n        mainReject(new Errors.ValidationError(\"One of the documents is not valid. Original error:\\n\"+error.message))\n      });\n    }\n  })\n\n  if (!isArray) {\n    return p.get(0);\n  }\n\n  return p;\n}\n\n\nModel.prototype.define = function(key, fn) {\n  this._methods[key] = fn;\n}\nModel.prototype.defineStatic = function(key, fn) {\n  this._staticMethods[key] = fn;\n\n  this[key] = function() {\n    return fn.apply(this, arguments);\n  };\n}\n\n\n\nModel.prototype._parse = function(data, ungroup) {\n  var self = this;\n  var promises = [];\n  var promise;\n\n  var p = new Promise(function(resolve, reject) {\n    if (ungroup) {\n      for(var i=0; i<data.length; i++) {\n        for(var j=0; j<data[i].reduction.length; j++) {\n          util.tryCatch(function() {\n            var newDoc = new self(data[i].reduction[j]);\n            newDoc.setSaved(true);\n            newDoc._emitRetrieve();\n            data[i].reduction[j] = newDoc;\n          }, reject)\n        }\n      }\n      return resolve(data);\n    }\n    else if (Array.isArray(data)) {\n      util.tryCatch(function() {\n        for(var i=0; i<data.length; i++) {\n          data[i] = new self(data[i])\n          data[i].setSaved(true);\n\n          self.emit('retrieved', data[i]);\n\n          (function(i) {\n            // Order matters here, we want the hooks to be executed *before* calling validate\n            promise = util.hook({\n              postHooks: data[i]._getModel()._post.retrieve,\n              doc: data[i],\n              async: data[i]._getModel()._async.retrieve,\n              fn: function() {}\n            })\n            if (promise instanceof Promise) {\n              promise.then(function() {\n                var promise = data[i].validate();\n                if (promise instanceof Promise) {\n                  promise.then(function() {\n                    resolve(data)\n                  }).error(reject);\n                }\n                else {\n                  resolve(data);\n                }\n              }).error(reject);\n              promises.push(promise);\n            }\n            else {\n              promise = data[i].validate();\n              if (promise instanceof Promise) promises.push(promise);\n            }\n          })(i);\n        }\n      }, function(error) {\n        var newError = new Error(\"The results could not be converted to instances of `\"+self.getTableName()+\"`\\nDetailed error: \"+error.message);\n\n        return reject(newError);\n      });\n\n      if (promises.length > 0) {\n        Promise.all(promises).then(function() {\n          resolve(data);\n        }).error(reject);\n      }\n      else {\n        resolve(data);\n      }\n    }\n    else {\n      // If we get a GROUPED_DATA, we convert documents in each group\n      if (util.isPlainObject(data) && (data.$reql_type$ === \"GROUPED_DATA\")) {\n        var result = [];\n        util.tryCatch(function() {\n          var reduction, newDoc;\n          for(var i=0; i<data.data.length; i++) {\n            (function(i) {\n              reduction = [];\n              if (Array.isArray(data.data[i][1])) {\n                for(var j=0; j<data.data[i][1].length; j++) {\n                  (function(j) {\n                    newDoc = new self(data.data[i][1][j]);\n                    newDoc.setSaved(true);\n\n                    newDoc._emitRetrieve();\n\n                    promise = util.hook({\n                      postHooks: newDoc._getModel()._post.retrieve,\n                      doc: newDoc,\n                      async: newDoc._getModel()._async.retrieve,\n                      fn: function() {}\n                    })\n                    if (promise instanceof Promise) {\n                      promise.then(function() {\n                        var promise = newDoc.validate();\n                        if (promise instanceof Promise) {\n                          promise.then(function() {\n                            resolve(data)\n                          }).error(reject);\n                        }\n                        else {\n                          resolve(data);\n                        }\n                      }).error(reject);\n                      promises.push(promise);\n                    }\n                    else {\n                      promise = newDoc.validate();\n                      if (promise instanceof Promise) promises.push(promise);\n                    }\n\n                    reduction.push(newDoc)\n                  })(j);\n                }\n                result.push({\n                  group: data.data[i][0],\n                  reduction: reduction\n                })\n              }\n              else {\n                newDoc = new self(data.data[i][1]);\n                newDoc.setSaved(true);\n\n                newDoc._emitRetrieve();\n\n                promise = util.hook({\n                  postHooks: newDoc._getModel()._post.retrieve,\n                  doc: newDoc,\n                  async: newDoc._getModel()._async.retrieve,\n                  fn: function() {}\n                })\n                if (promise instanceof Promise) {\n                  promise.then(function() {\n                    var promise = newDoc.validate();\n                    if (promise instanceof Promise) {\n                      promise.then(function() {\n                        resolve(result)\n                      }).error(reject);\n                    }\n                    else {\n                      resolve(result);\n                    }\n                  }).error(reject);\n                  promises.push(promise);\n                }\n                else {\n                  promise = newDoc.validate();\n                  if (promise instanceof Promise) promises.push(promise);\n                }\n\n                result.push({\n                  group: data.data[i][0],\n                  reduction: newDoc\n                })\n              }\n            })(i);\n          }\n        }, reject);\n        if (promises.length > 0) {\n          Promise.all(promises).then(function() {\n            resolve(result)\n          }).error(reject);\n        }\n        else {\n          resolve(result);\n        }\n      }\n      else {\n        if (data === null) { // makeDocument is true, but we got `null`\n          reject(new Error(\"Cannot build a new instance of `\"+self.getTableName()+\"` with `null`.\"))\n        }\n        else {\n          util.tryCatch(function() {\n            var newDoc = new self(data);\n            newDoc.setSaved(true);\n\n            newDoc._emitRetrieve();\n\n            promise = util.hook({\n              postHooks: newDoc._getModel()._post.retrieve,\n              doc: newDoc,\n              async: newDoc._getModel()._async.retrieve,\n              fn: function() {}\n            })\n            if (promise instanceof Promise) {\n              promise.then(function() {\n                var promise = newDoc.validate();\n                if (promise instanceof Promise) {\n                  promise.then(function() {\n                    resolve(newDoc);\n                  }).error(reject);\n                }\n                else {\n                  resolve(newDoc);\n                }\n              }).error(reject);\n            }\n            else {\n              promise = newDoc.validate();\n            }\n\n            if (promise instanceof Promise) {\n              promise.then(function() {\n                resolve(newDoc)\n              }).error(function(err) {\n                reject(err)\n              });\n            }\n            else {\n              resolve(newDoc);\n            }\n          }, reject);\n        }\n      }\n    }\n  })\n  return p;\n}\n\n/*\n * Implement an interface similar to events.EventEmitter\n */\nModel.prototype.docAddListener = function(eventKey, listener) {\n  var listeners = this._getModel()._listeners;\n  if (listeners[eventKey] == null) {\n    listeners[eventKey] = [];\n  }\n  listeners[eventKey].push({\n    once: false,\n    listener: listener\n  });\n}\nModel.prototype.docOn = Model.prototype.docAddListener;\n\nModel.prototype.docOnce = function(eventKey, listener) {\n  var listeners = this._getModel()._listeners;\n  if (listeners[eventKey] == null) {\n    listeners[eventKey] = [];\n  }\n  listeners[eventKey].push({\n    once: true,\n    listener: listener\n  });\n}\n\nModel.prototype.docListeners = function(eventKey, raw) {\n  if (eventKey == null) {\n    return this._getModel()._listeners\n  }\n\n  raw = raw || true;\n  if (raw === true) {\n    return this._getModel()._listeners[eventKey];\n  }\n  else {\n    return this._getModel()._listeners[eventKey].map(function(fn) {\n      return fn.listener;\n    });\n  }\n}\n\nModel.prototype.docSetMaxListeners = function(n) {\n  this._getModel()._maxListeners = n;\n}\n\nModel.prototype.docRemoveListener = function(ev, listener) {\n  if (Array.isArray(this._getModel()._listeners[ev])) {\n    for(var i=0; i<this._getModel()._listeners[ev].length; i++) {\n      if (this._getModel()._listeners[ev][i] === listener) {\n        this._getModel()._listeners[ev].splice(i, 1);\n        break;\n      }\n    }\n  }\n}\n\nModel.prototype.docRemoveAllListeners = function(ev) {\n  if (ev === undefined) {\n    delete this._getModel()._listeners[ev]\n  }\n  else {\n    this._getModel()._listeners = {};\n  }\n}\n\nModel.prototype.pre = function(ev, fn) {\n  if (typeof fn !== \"function\") {\n    throw new Error(\"Second argument to `pre` must be a function\");\n  }\n  if (fn.length > 1) {\n    throw new Error(\"Second argument to `pre` must be a function with at most one argument.\");\n  }\n  if (Array.isArray(this._pre[ev]) === false) {\n    throw new Error(\"No pre-hook available for the event `\"+ev+\"`.\")\n  }\n  this._getModel()._async[ev] = this._getModel()._async[ev] || (fn.length === 1)\n  this._getModel()._pre[ev].push(fn);\n}\n\nModel.prototype.post = function(ev, fn) {\n  if (typeof fn !== \"function\") {\n    throw new Error(\"Second argument to `pre` must be a function\");\n  }\n  if (fn.length > 1) {\n    throw new Error(\"Second argument to `pre` must be a function with at most one argument.\");\n  }\n  if (Array.isArray(this._post[ev]) === false) {\n    throw new Error(\"No post-hook available for the event `\"+ev+\"`.\")\n  }\n  this._getModel()._async[ev] = this._getModel()._async[ev] || (fn.length === 1)\n  this._getModel()._post[ev].push(fn);\n}\n\nmodule.exports = Model;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/util.js":"var util = {};\nvar Promise = require('bluebird');\nvar EventEmitter = require('events').EventEmitter;\nvar Errors = require(__dirname+'/errors.js');\n\n/**\n * Random useful methods used everywhere.\n */\n\n\n/**\n * Is `obj` a plain object.\n * @return {boolean}\n */\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\nutil.isPlainObject = isPlainObject;\n\n\n/**\n * Make a \"deep copy\".\n * The prototype chain is not copied.\n */\nfunction deepCopy(value) {\n  var result;\n  if (value instanceof Buffer) {\n    // isPlainObject(buffer) returns true.\n    return new Buffer(value);\n  }\n\n  if (isPlainObject(value) === true) {\n    result = {};\n    loopKeys(value, function(_value, key) {\n      if (_value.hasOwnProperty(key)) {\n        result[key] = deepCopy(_value[key]);\n      }\n    });\n    return result;\n  }\n\n  if (Array.isArray(value)) {\n    result = []\n    for(var i=0; i<value.length; i++) {\n      result.push(deepCopy(value[i]));\n    }\n    return result;\n  }\n\n  return value;\n}\nutil.deepCopy = deepCopy;\n\n\n/**\n * Wrap try/catch for v8\n */\nfunction tryCatch(toTry, handleError) {\n  try{\n    toTry()\n  }\n  catch(err) {\n    handleError(err)\n  }\n}\nutil.tryCatch = tryCatch;\n\n\n/**\n * Return a promise if a hook is asynchronous\n * Note: If no hook is asynchronous, `fn` can still be asynchronous in which\n * case we return a promise or undefined\n * @param {Object} options, the arguments are:\n * - preHooks {Array} the methods to execute before the main one\n * - postHooks {Array} the methods to execute after the main one\n * - async {boolean} whether this this hook is asynchronous or not\n * - doc {Document} the document that triggered the hooks\n * - fn {Function} the main function\n * - fnArgs {Array} arguments for `fn`\n * @return {Promise=}\n */\nfunction hook(options) {\n  var preHooks = options.preHooks;\n  if (Array.isArray(preHooks) === false) {\n    preHooks = [];\n  }\n  var postHooks = options.postHooks;\n  if (Array.isArray(postHooks) === false) {\n    postHooks = [];\n  }\n  var doc = options.doc; // We need the doc to set the context of the hooks\n  var async = options.async || false;\n  var fn = options.fn; // The function that we are hook\n  var fnArgs = options.fnArgs;\n\n  if (async === true) {\n    return new Promise(function(resolve, reject) {\n      _asyncHook({\n        resolve: resolve,\n        reject: reject,\n        preHooks: preHooks,\n        postHooks: postHooks,\n        doc: doc,\n        fn: fn,\n        fnArgs: fnArgs\n      });\n    });\n  }\n\n  return _syncHook({\n    preHooks: preHooks,\n    postHooks: postHooks,\n    doc: doc,\n    fn: fn,\n    fnArgs: fnArgs\n  });\n}\nfunction _syncHook(args) {\n  var preHooks = args.preHooks;\n  var postHooks = args.postHooks;\n  var fn = args.fn;\n  var doc = args.doc;\n  var fnArgs = args.fnArgs;\n\n  for(var i=0; i<preHooks.length; i++) {\n    preHooks[i].call(doc);\n  }\n  var result = fn.apply(doc, fnArgs);\n  for(var j=0; j<postHooks.length; j++) {\n    postHooks[j].call(doc);\n  }\n  return result;\n}\nfunction _asyncHook(args) {\n  // One of the hook, or the function is asynchronous, so we will\n  // always return a promise\n  // We only need to keep track of the result return/resolved for fn\n\n  var preHooks = args.preHooks;\n  var postHooks = args.postHooks;\n  var fn = args.fn;\n  var fnArgs = args.fnArgs;\n  var doc = args.doc;\n  var resolve = args.resolve;\n  var reject = args.reject;\n  var args = args.args;\n\n  var result;\n\n  var nextPost = function() {\n    if (typeof resolve === \"function\") {\n      resolve(result);\n    }\n    return result;\n  }\n\n  var executeMain = function() {\n    result = fn.apply(doc, fnArgs);\n    if (result instanceof Promise) {\n      return result.then(function(res) {\n        result = res;\n        executeHooks(0, postHooks, doc, reject, nextPost);\n      }).error(reject);\n    }\n    return executeHooks(0, postHooks, doc, reject, nextPost);\n  }\n\n  var nextPre = function() {\n    tryCatch(executeMain, function (err) {\n      return reject(err);\n    });\n  }\n  return executeHooks(0, preHooks, doc, reject, nextPre);\n}\nutil.hook = hook;\n\nfunction executeHooks(hookIndex, hooks, doc, reject, next) {\n  if (hookIndex < hooks.length) {\n    if (hooks[hookIndex].length === 1) {\n      hooks[hookIndex].call(doc, function(err) {\n        if (err) return reject(err);\n        executeHooks(hookIndex+1, hooks, doc, reject, next)\n      });\n    }\n    else {\n      hooks[hookIndex].call(doc);\n      executeHooks(hookIndex+1, hooks, doc, reject, next)\n    }\n  }\n  else {\n    next();\n  }\n}\n\nfunction loopKeys(obj, fn) {\n  if (isPlainObject(obj)) {\n    var keys = Object.keys(obj);\n    var result;\n    for(var i=0; i<keys.length; i++) {\n      result = fn(obj, keys[i]);\n      if (result === false) return;\n    }\n  }\n}\nutil.loopKeys = loopKeys;\n\nfunction changeProto(object, newProto) {\n  object.__proto__ = newProto;\n}\nutil.changeProto = changeProto;\n\nfunction recurse(key, joins, modelTo, all, done) {\n  return (util.isPlainObject(modelTo) && modelTo.hasOwnProperty(key))\n    || ((all === true) && (done[joins[key].model.getTableName()] !== true))\n}\nutil.recurse = recurse;\n\nfunction bindEmitter(self) {\n  util.loopKeys(EventEmitter.prototype, function(emitter, key) {\n    var fn = emitter[key];\n    if (typeof fn === 'function') {\n      self[key] = function() {\n        var args = new Array(arguments.length);\n        for(var i = 0; i < arguments.length; i++) {\n          args[i] = arguments[i];\n        }\n        fn.apply(self, args);\n      }\n    }\n  });\n}\nutil.bindEmitter = bindEmitter;\n\nfunction mergeOptions(options, newOptions) {\n  if (util.isPlainObject(newOptions)) {\n    if (!options) {\n      options = {};\n    }\n    var localOptions = {};\n    localOptions.enforce_missing = (newOptions.enforce_missing != null) ? newOptions.enforce_missing : options.enforce_missing;\n    localOptions.enforce_type = (newOptions.enforce_type != null) ? newOptions.enforce_type : options.enforce_type;\n    localOptions.enforce_extra = (newOptions.enforce_extra != null) ? newOptions.enforce_extra : options.enforce_extra;\n    return localOptions;\n  }\n  return options;\n}\nutil.mergeOptions = mergeOptions;\n\nfunction extractPrimaryKey(oldValue, newValue, primaryKey) {\n  var primaryKey;\n  if (oldValue !== null) {\n    return oldValue[primaryKey];\n  }\n  if (newValue !== null) {\n    return newValue[primaryKey];\n  }\n  return undefined;\n}\nutil.extractPrimaryKey = extractPrimaryKey;\n\n\nfunction undefinedField(prefix) {\n  throw new Errors.ValidationError(\"Value for \"+prefix+\" must be defined.\")\n}\nutil.undefinedField = undefinedField;\n\n\nvar vowels = {a: true, e: true, i: true, o: true, u: true};\nfunction strictType(prefix, expected) {\n  if ((expected.length > 0) && (vowels[expected[0]])) {\n    throw new Errors.ValidationError(\"Value for \"+prefix+\" must be an \"+expected+\".\")\n  }\n  throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a \"+expected+\".\")\n}\nutil.strictType = strictType;\n\n\nfunction extraField(prefix, key) {\n  if (prefix === '') {\n    throw new Errors.ValidationError(\"Extra field `\"+key+\"` not allowed.\")\n  }\n  throw new Errors.ValidationError(\"Extra field `\"+key+\"` in \"+prefix+\" not allowed.\")\n}\nutil.extraField = extraField;\n\n\nfunction looseType(prefix, expected) {\n  if ((expected.length > 0) && (vowels[expected[0]])) {\n    throw new Errors.ValidationError(\"Value for \"+prefix+\" must be an \"+expected+\" or null.\")\n  }\n  throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a \"+expected+\" or null.\")\n}\nutil.looseType = looseType;\n\n\nfunction pseudoTypeError(type, missingField, prefix) {\n  throw new Errors.ValidationError(\"The raw \"+type+\" object for \"+prefix+\" is missing the required field \"+missingField+\".\")\n}\nutil.pseudoTypeError = pseudoTypeError;\n\n\n// Return true if doc is undefined, else false\nfunction validateIfUndefined(value, prefix, type, options) {\n  if (value === undefined) {\n    if (options.enforce_missing === true) {\n      undefinedField(prefix);\n    }\n    return true;\n  }\n  return false;\n}\nutil.validateIfUndefined = validateIfUndefined;\n\nfunction toArray(args) {\n    return Array.prototype.slice.call(args);\n}\nutil.toArray = toArray;\n\nmodule.exports = util;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/errors.js":"\"use strict\";\n\nvar util = require('util');\nvar errors = module.exports = {};\n\n/**\n * The base error that all thinky related errors derive from\n *\n * @constructor\n * @alias Error\n */\nerrors.ThinkyError = function() {\n  var tmp = Error.apply(this, arguments);\n  tmp.name = this.name = 'ThinkyError';\n\n  this.message = tmp.message;\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, this.constructor);\n};\nutil.inherits(errors.ThinkyError, Error);\n\n/**\n * Thrown or returned when `get` returns `null`.\n * @extends ThinkyError\n */\nerrors.DocumentNotFound = function(message) {\n  var errorMessage = message || \"The query did not find a document and returned null.\";\n  errors.ThinkyError.call(this, errorMessage);\n  this.name = 'DocumentNotFoundError';\n};\nutil.inherits(errors.DocumentNotFound, errors.ThinkyError);\n\n/**\n * Thrown or returned when an in place update/replace returns an invalid document.\n * @extends ThinkyError\n */\nerrors.InvalidWrite = function(message, raw) {\n  errors.ThinkyError.call(this, message);\n  this.name = 'InvalidWriteError';\n  this.raw = raw;\n};\nutil.inherits(errors.InvalidWrite, errors.ThinkyError);\n\n/**\n * Thrown or returned when validation of a document fails.\n * @extends ThinkyError\n */\nerrors.ValidationError = function(message) {\n  errors.ThinkyError.call(this, message);\n  this.name = 'ValidationError';\n};\nutil.inherits(errors.ValidationError, errors.ThinkyError);\n\n/**\n * Thrown or returned when the primary key unique document constraint fails.\n * @extends ThinkyError\n */\nerrors.DuplicatePrimaryKey = function(message, primaryKey) {\n  errors.ThinkyError.call(this, message);\n  this.name = 'DuplicatePrimaryKeyError';\n  if (primaryKey !== undefined) {\n    this.primaryKey = primaryKey;\n  }\n};\nutil.inherits(errors.DuplicatePrimaryKey, errors.ThinkyError);\n\n/**\n * regular expressions used to determine which errors should be thrown\n */\nerrors.DOCUMENT_NOT_FOUND_REGEX = new RegExp('^The query did not find a document and returned null.*');\nerrors.DUPLICATE_PRIMARY_KEY_REGEX = new RegExp('^Duplicate primary key `(.*)`.*');\n\n/**\n * Creates an appropriate error given either an instance of Error or a message\n * from the RethinkDB driver\n */\nerrors.create = function(errorOrMessage) {\n  var message = (errorOrMessage instanceof Error) ? errorOrMessage.message : errorOrMessage;\n  if (message.match(errors.DOCUMENT_NOT_FOUND_REGEX)) {\n    return new errors.DocumentNotFound(message);\n  } else if (message.match(errors.DUPLICATE_PRIMARY_KEY_REGEX)) {\n    var primaryKey = message.match(errors.DUPLICATE_PRIMARY_KEY_REGEX)[1];\n    return new errors.DuplicatePrimaryKey(message, primaryKey);\n  } else if (errorOrMessage instanceof Error) {\n    return errorOrMessage;\n  }\n\n  return new errors.ThinkyError(errorOrMessage);\n};\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/schema.js":"var arrayPrefix = \"__array\"\nmodule.exports.arrayPrefix = arrayPrefix;\n\nvar util = require(__dirname+'/util.js');\nvar type = require(__dirname+'/type/index.js');\nvar Errors = require(__dirname+'/errors.js');\n\n\nfunction generateVirtual(doc, defaultField, originalDoc, virtual) {\n  var path = defaultField.path;\n  var value = defaultField.value;\n  var field = doc;\n\n  var keepGoing = true;\n  var virtualValue = virtual;\n\n  for(var j=0; j<path.length-1; j++) {\n    if (util.isPlainObject(virtualValue)) {\n      virtualValue = virtualValue[path[j]];\n    }\n    else {\n      virtualValue = undefined;\n    }\n\n    if (path[j] === arrayPrefix) {\n      if (!Array.isArray(field)) {\n        // This is caught by validate, except if there is an `enforce_type: \"none\"`.\n        return;\n      }\n      else {\n        for(var k=0; k<field.length; k++) {\n          if (virtual != null) {\n            virtualValue = virtual[k];\n          }\n          generateVirtual(field[k], {path: defaultField.path.slice(j+1), value: defaultField.value}, this, virtualValue);\n        }\n      }\n      keepGoing = false;\n    }\n    else {\n      // field cannot be undefined (doc is not undefined on the first iteration, and we'll return if it becomes undefined\n      field = field[path[j]];\n      if (field === undefined) {\n        // We do not populate parent of default fields by default\n        return;\n      }\n    }\n  }\n  if (keepGoing) {\n    if (value === undefined) {\n      if (util.isPlainObject(virtualValue) && (virtualValue[[path[path.length-1]]] !== undefined)) {\n        field[path[path.length-1]] = virtualValue[[path[path.length-1]]];\n      }\n    }\n    else if ((typeof value === \"function\") && !Array.isArray(value._query)) {\n      field[path[path.length-1]] = value.call(doc);\n    }\n    else {\n      if (util.isPlainObject(value)) {\n        field[path[path.length-1]] = util.deepCopy(value);\n      }\n      else if (value !== undefined) {\n        field[path[path.length-1]] = value;\n      }\n    }\n  }\n  return doc;\n}\n\nmodule.exports.generateVirtual = generateVirtual;\n\nfunction generateDefault(doc, defaultField, originalDoc) {\n  var path = defaultField.path;\n  var value = defaultField.value;\n  var field = doc;\n\n  var keepGoing = true;\n  for(var j=0; j<path.length-1; j++) {\n    if (path[j] === arrayPrefix) {\n      if (!Array.isArray(field)) {\n        // This is caught by validate, except if there is an `enforce_type: \"none\"`.\n        return;\n      }\n      else {\n        for(var k=0; k<field.length; k++) {\n          generateDefault(field[k], {path: defaultField.path.slice(j+1), value: defaultField.value}, this);\n        }\n      }\n      keepGoing = false;\n    }\n    else {\n      field = field[path[j]];\n      if (field === undefined) {\n        // We do not populate parent of default fields by default\n        return;\n      }\n    }\n  }\n  if (keepGoing && util.isPlainObject(field) && field[path[path.length-1]] === undefined) {\n    if ((typeof value === \"function\") && !Array.isArray(value._query)) {\n      field[path[path.length-1]] = value.call(doc);\n    }\n    else {\n      if (util.isPlainObject(value) || Array.isArray(value)) {\n        field[path[path.length-1]] = util.deepCopy(value);\n      }\n      else {\n        field[path[path.length-1]] = value;\n      }\n    }\n  }\n  return doc;\n}\n\nmodule.exports.generateDefault = generateDefault;\n\nfunction parse(schema, prefix, options, model) {\n  var result;\n\n  if ((prefix === '') && (type.isObject(schema) === false) && (util.isPlainObject(schema) === false)) {\n    throw new Errors.ValidationError(\"The schema must be a plain object.\")\n  }\n\n  // Validate a schema and add the field _enum if needed\n  if (util.isPlainObject(schema)) {\n    if (schema._type !== undefined) {\n      options = util.mergeOptions(options, schema.options);\n      var result;\n      switch(schema._type) {\n        case String:\n          result = type.string().options(options).validator(schema.validator).enum(schema.enum);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          if (typeof schema.min === \"number\") { result.min(schema.min); }\n          if (typeof schema.max === \"number\") { result.max(schema.max); }\n          if (typeof schema.length === \"number\") { result.length(schema.length); }\n          if (schema.alphanum === true) { result.alphanum(); }\n          if (schema.lowercase === true) { result.lowercase(); }\n          if (schema.uppercase === true) { result.uppercase(); }\n          if (typeof schema.regex === \"string\") { result.regex(regex, schema.flags); }\n          return result;\n        case Number:\n          result = type.number().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          if (typeof schema.min === \"number\") { result.min(schema.min); }\n          if (typeof schema.max === \"number\") { result.max(schema.max); }\n          if (typeof schema.length === \"number\") { result.length(schema.length); }\n          if (schema.integer === true) { result.integer(); }\n          return result;\n        case Boolean:\n          result = type.boolean().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          return result;\n        case Date:\n          var result = type.date().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          if (schema.min instanceof Date) { result.min(schema.min); }\n          if (schema.max instanceof Date) { result.max(schema.max); }\n          return result;\n        case Buffer:\n          result = type.buffer().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          return result\n        case Object:\n          result = type.object().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          util.loopKeys(schema.schema, function(_schema, key) {\n            result.setKey(key, parse(_schema[key], prefix+\"[\"+key+\"]\", options));\n          })\n          if (prefix === '') {\n            result._setModel(model)\n          }\n          return result;\n        case Array:\n          var result = type.array().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          if (schema.schema !== undefined) {\n            result.schema(parse(schema.schema, prefix+\"[0]\", options));\n          }\n          if (typeof schema.min === \"number\") { result.min(schema.min); }\n          if (typeof schema.max === \"number\") { result.max(schema.max); }\n          if (typeof schema.length === \"number\") { result.length(schema.length); }\n          return result;\n        case 'Point':\n          result = type.point().options(options).validator(schema.validator);\n          if (schema.default !== undefined) { result.default(schema.default); }\n          return result;\n        case 'virtual':\n          result = type.virtual();\n          if (schema.default !== undefined) { result.default(schema.default); }\n          return result\n        default: // Unknown type\n          throw new Errors.ValidationError(\"The field `_type` must be `String`/`Number`/`Boolean`/`Date`/`Buffer`/`Object`/`Array`/`'virtual'`/`'Point'` for \"+prefix);\n      }\n    }\n    else if (type.isString(schema)\n        || type.isNumber(schema)\n        || type.isBoolean(schema)\n        || type.isDate(schema)\n        || type.isBuffer(schema)\n        || type.isPoint(schema)\n        || type.isObject(schema)\n        || type.isArray(schema)\n        || type.isAny(schema)\n        || type.isVirtual(schema)){ // Unknown type\n      // Nothing to do here\n      if (type.isObject(schema)) {\n        parse(schema._schema, prefix, options);\n      }\n      else if (type.isArray(schema)) {\n        if (schema._schema == undefined) {\n          schema._schema = parse(type.any(), prefix, options);\n        }\n        else {\n          schema._schema = parse(schema._schema, prefix, options);\n        }\n      }\n\n      // We want to copy the model object here\n      if (util.isPlainObject(schema._options) === false) {\n        schema.options(options);\n      }\n      else if ((schema._options.enforce_extra === undefined)\n          || (schema._options.enforce_missing === undefined)\n          || (schema._options.enforce_type === undefined)) {\n        var newOptions = {};\n        newOptions.enforce_missing = (schema._options.enforce_missing != null) ? schema._options.enforce_missing : options.enforce_missing;\n        newOptions.enforce_extra = (schema._options.enforce_extra != null) ? schema._options.enforce_extra : options.enforce_extra;\n        newOptions.enforce_type = (schema._options.enforce_type != null) ? schema._options.enforce_type : options.enforce_type;\n        schema.options(newOptions);\n      }\n      return schema;\n    }\n    else {\n      result = type.object().options(options);\n      util.loopKeys(schema, function(_schema, key) {\n        result.setKey(key, parse(_schema[key], prefix+\"[\"+key+\"]\", options));\n      })\n      if (prefix === '') {\n        result._setModel(model)\n      }\n      return result;\n    }\n  }\n  else if (Array.isArray(schema)) {\n    result = type.array().options(options);\n    if (schema.length > 1) {\n      throw new Errors.ValidationError(\"An array in a schema can have at most one element. Found \"+schema.length+\" elements in \"+prefix)\n    }\n\n    if (schema.length > 0) {\n      result.schema(parse(schema[0], prefix+\"[0]\", options));\n    }\n    return result;\n\n  }\n  else if (schema === String) {\n    return type.string().options(options);\n  }\n  else if (schema === Number) {\n    return type.number().options(options);\n  }\n  else if (schema === Boolean) {\n    return type.boolean().options(options);\n  }\n  else if (schema === Date) {\n    return type.date().options(options);\n  }\n  else if (schema === Buffer) {\n    return type.buffer().options(options);\n  }\n  else if (schema === Object) {\n    return type.object().options(options);\n  }\n  else if (schema === Array) {\n    return type.array().options(options);\n  }\n  else if (schema === 'Point') {\n    return type.point().options(options);\n  }\n  else if (schema === 'virtual') {\n    return type.virtual().options(options);\n  }\n  else {\n    throw new Errors.ValidationError(\"The value must be `String`/`Number`/`Boolean`/`Date`/`Buffer`/`Object`/`Array`/`'virtual'`/`'Point'` for \"+prefix);\n  }\n}\nmodule.exports.parse = parse;\n\n// The schema doesn't contain joined docs\nfunction validate(doc, schema, prefix, options) {\n  schema.validate(doc, prefix, options);\n}\nmodule.exports.validate = validate;\n\nfunction getType(schema) {\n  if (util.isPlainObject(schema) && (schema._type !== undefined)) {\n    return schema._type;\n  }\n  return schema;\n}\n\n\nfunction validateEnum(doc, schema, prefix) {\n  if (Array.isArray(schema.enum) && (schema._enum[doc] !== true)) {\n    var validValues = Object.keys(schema._enum);\n    var message = \"The field \"+prefix+\" must be one of these values: \"\n\n    for(var i=0; i<validValues.length; i++) {\n      if (i === 10) { break; }\n      if ((i === validValues.length-1) || (i === 9)) {\n        message = message+validValues[i]\n      }\n      else {\n        message = message+validValues[i]+\", \"\n      }\n    }\n    if (validValues.length > 10) {\n      message = message+\"...\"\n    }\n    else {\n      message = message+\".\"\n    }\n\n    throw new Errors.ValidationError(message);\n  }\n}\n// Check that schema is a valid object first\nfunction validateCustomizedValidator(doc, schema, prefix) {\n  if (typeof schema.validator === 'function') {\n    if (schema.validator(doc) === false) {\n      throw new Errors.ValidationErrors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n    }\n  }\n}\n\nfunction validateString(doc, schema, prefix, options) {\n  if (validateNotNullUndefined(doc, prefix, \"string\", options)) return;\n\n  if (typeof doc !== \"string\") { // doc is not null/undefined\n    if (options.enforce_type === \"strict\") {\n      strictType(prefix, \"string\");\n    }\n    else if (options.enforce_type === \"loose\") {\n      looseType(prefix, \"string\");\n    }\n  }\n\n  if (util.isPlainObject(schema)) {\n    validateCustomizedValidator(doc, schema, prefix);\n    validateEnum(doc, schema, prefix);\n  }\n}\n\nfunction validateNumber(doc, schema, prefix, options) {\n  if (validateNotNullUndefined(doc, prefix, \"number\", options)) return;\n\n  if (typeof doc !== \"number\") { // doc is not null/undefined\n    if (options.enforce_type === \"strict\") {\n      strictType(prefix, \"number\");\n    }\n    else if (options.enforce_type === \"loose\") {\n      looseType(prefix, \"number\");\n    }\n  }\n\n  if (util.isPlainObject(schema)) {\n    validateCustomizedValidator(doc, schema, prefix);\n    validateEnum(doc, schema, prefix);\n  }\n\n}\n\nfunction validateBoolean(doc, schema, prefix, options) {\n  if (validateNotNullUndefined(doc, prefix, \"boolean\", options)) return;\n\n  if (typeof doc !== \"boolean\") { // doc is not null/undefined\n    if (options.enforce_type === \"strict\") {\n      strictType(prefix, \"boolean\");\n    }\n    else if (options.enforce_type === \"loose\") {\n      looseType(prefix, \"boolean\");\n    }\n  }\n\n  if (util.isPlainObject(schema)) {\n    validateCustomizedValidator(doc, schema, prefix);\n    validateEnum(doc, schema, prefix);\n  }\n}\n\nfunction validateDate(doc, schema, prefix, options) {\n  if (validateNotNullUndefined(doc, prefix, \"date\", options)) return;\n\n  if (options.enforce_type !== \"none\") {\n    if (util.isPlainObject(doc) && (doc[\"$reql_type$\"] === \"TIME\")) {\n      if (doc.epoch_time === undefined) {\n        pseudoTypeError(\"date\", \"epoch_time\", prefix);\n      }\n      else if (doc.timezone === undefined) {\n        pseudoTypeError(\"date\", \"timezone\", prefix);\n      }\n    }\n    else if ((typeof doc === 'function') && (Array.isArray(doc._query))) {\n      // TOIMPROVE -- we currently just check if it's a term from the driver\n      // We suppose for now that this is enough and we don't throw an error\n    }\n    else if (typeof doc === 'string') {\n      var date = new Date(doc);\n      if (date.getTime() !== date.getTime()) {\n        if (options.enforce_type === \"strict\") {\n          strictType(prefix, \"date or a valid string\");\n        }\n        else if (options.enforce_type !== \"none\") {\n          looseType(prefix, \"date or a valid string\");\n        }\n      }\n    }\n    else if ((doc instanceof Date) === false)  {\n      if (options.enforce_type === \"strict\") {\n        strictType(prefix, \"date\");\n      }\n      else if (options.enforce_type !== \"none\") {\n        looseType(prefix, \"date\");\n      }\n    }\n  }\n\n  if (util.isPlainObject(schema)) {\n    validateCustomizedValidator(doc, schema, prefix);\n  }\n}\n\nfunction validatePoint(doc, schema, prefix, options) {\n  if (validateNotNullUndefined(doc, prefix, \"point\", options)) return;\n\n  if (options.enforce_type !== \"none\") {\n    if (util.isPlainObject(doc) && (doc[\"$reql_type$\"] === \"GEOMETRY\")) {\n      if (doc.type === undefined) {\n        pseudoTypeError(\"Point\", \"type\", prefix);\n      }\n      else if (doc.type !== \"Point\") {\n        throw new Errors.ValidationError(\"The field `type` for \"+prefix+\" must be `'Point'`.\")\n      }\n      else if (doc.coordinates === undefined) {\n        pseudoTypeError(\"date\", \"coordinates\", prefix);\n      }\n      else if ((!Array.isArray(doc.coordinates)) || (doc.coordinates.length !== 2)) {\n        throw new Errors.ValidationError(\"The field `coordinates` for \"+prefix+\" must be an Array of two numbers.\")\n      }\n    }\n    else if (util.isPlainObject(doc) && (doc.type === \"Point\") && (Array.isArray(doc.coordinates)) && (doc.coordinates.length === 2)) { // Geojson\n      // Geojson format\n    }\n    else if ((typeof doc === 'function') && (Array.isArray(doc._query))) {\n      // TOIMPROvE -- we currently just check if it's a term from the driver\n      // We suppose for now that this is enough and we don't throw an error\n    }\n    else if (util.isPlainObject(doc)) {\n      var keys = Object.keys(doc).sort();\n      if (((keys.length !== 2) || keys[0] !== 'latitude') || (keys[1] !== 'longitude') || (typeof doc.latitude !== \"number\") || (typeof doc.longitude !== \"number\")) {\n        throw new Errors.ValidationError(\"The value for \"+prefix+\" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].\")\n      }\n      else if ((typeof doc.latitude !== 'number') || (typeof doc.latitude !== 'number')) {\n        throw new Errors.ValidationError(\"The value for \"+prefix+\" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].\")\n      }\n    }\n    else if (Array.isArray(doc)) {\n      if ((doc.length !== 2) || (typeof doc[0] !== \"number\") || (typeof doc[1] !== \"number\")) {\n        throw new Errors.ValidationError(\"The value for \"+prefix+\" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].\")\n      }\n    }\n  }\n  if (util.isPlainObject(schema)) {\n    validateCustomizedValidator(doc, schema, prefix);\n  }\n}\n\nfunction validateBuffer(doc, schema, prefix, options) {\n  if (validateNotNullUndefined(doc, prefix, \"buffer\", options)) return;\n\n  if (util.isPlainObject(doc) && (doc[\"$reql_type$\"] === \"BINARY\")) {\n    if (doc.data === undefined) {\n      pseudoTypeError(\"binary\", \"data\", prefix);\n    }\n  }\n  else if ((typeof doc === 'function') && (Array.isArray(doc._query))) {\n    // TOIMPROvE -- we currently just check if it's a term from the driver\n    // We suppose for now that this is enough and we don't throw an error\n  }\n  else if ((doc instanceof Buffer) === false)  {\n    if (options.enforce_type === \"strict\") {\n      strictType(prefix, \"buffer\");\n    }\n    else if (options.enforce_type !== \"none\") {\n      looseType(prefix, \"buffer\");\n    }\n  }\n\n  if (util.isPlainObject(schema)) {\n    validateCustomizedValidator(doc, schema, prefix);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/type/index.js":"var schema =      require(__dirname+'/../schema.js');\nvar util =        require(__dirname+'/../util.js');\nvar TypeAny =     require(__dirname+'/any.js');\nvar TypeArray =   require(__dirname+'/array.js');\nvar TypeBoolean = require(__dirname+'/boolean.js');\nvar TypeBuffer =  require(__dirname+'/buffer.js');\nvar TypeDate =    require(__dirname+'/date.js');\nvar TypeNumber =  require(__dirname+'/number.js');\nvar TypeObject =  require(__dirname+'/object.js');\nvar TypePoint =   require(__dirname+'/point.js');\nvar TypeString =  require(__dirname+'/string.js');\nvar TypeVirtual = require(__dirname+'/virtual.js');\n\n\n/**\n * Create a new Type that let users create sub-types.\n * @return {Type}\n */\nfunction Type() { }\n\n\n/**\n * Create a new TypeAny object\n * @return {TypeAny}\n */\n\nType.prototype.any = function() {\n  return new TypeAny();\n}\n\n\n/**\n * Create a new TypeString object.\n * @return {TypeString}\n */\nType.prototype.string = function() {\n  return new TypeString();\n}\n\n\n/**\n * Create a new TypeNumber object.\n * @return {TypeNumber}\n */\nType.prototype.number = function() {\n  return new TypeNumber();\n}\n\n\n/**\n * Create a new TypeBoolean object.\n * @return {TypeBoolean}\n */\nType.prototype.boolean = function() {\n  return new TypeBoolean();\n}\n\n\n/**\n * Create a new TypeDate object.\n * @return {TypeDate}\n */\nType.prototype.date = function() {\n  return new TypeDate();\n}\n\n\n/**\n * Create a new TypeBuffer object.\n * @return {TypeBuffer}\n */\nType.prototype.buffer = function() {\n  return new TypeBuffer();\n}\n\n\n/**\n * Create a new TypePoint object.\n * @return {TypePoint}\n */\nType.prototype.point = function() {\n  return new TypePoint();\n}\n\n\n/**\n * Create a new TypeObject object.\n * @return {TypeObject}\n */\nType.prototype.object = function() {\n  return new TypeObject();\n}\n\n\n/**\n * Create a new TypeArray object.\n * @return {TypeArray}\n */\nType.prototype.array = function() {\n  return new TypeArray();\n}\n\n\n/**\n * Create a new TypeVirtual object.\n * @return {TypeVirtual}\n */\nType.prototype.virtual = function() {\n  return new TypeVirtual();\n}\n\n\n/**\n * Create a new TypeString object to use as an id.\n * @return {TypeString}\n */\nType.prototype.id = function() {\n  return new TypeString().optional();\n}\n\n\n/**\n * Check if the first argument is a TypeString object or not\n * @param {Object} obj The object to check against TypeString.\n * @return {boolean}\n */\nType.prototype.isString = function(obj) {\n  return obj instanceof TypeString;\n}\n\n\n/**\n * Check if the first argument is a TypeNumber object or not\n * @param {Object} obj The object to check against TypeNumber.\n * @return {boolean}\n */\nType.prototype.isNumber = function(obj) {\n  return obj instanceof TypeNumber;\n}\n\n\n/**\n * Check if the first argument is a TypeBoolean object or not\n * @param {Object} obj The object to check against TypeBoolean.\n * @return {boolean}\n */\nType.prototype.isBoolean = function(obj) {\n  return obj instanceof TypeBoolean;\n}\n\n\n/**\n * Check if the first argument is a TypeDate object or not\n * @param {Object} obj The object to check against TypeDate.\n * @return {boolean}\n */\nType.prototype.isDate = function(obj) {\n  return obj instanceof TypeDate;\n}\n\n\n/**\n * Check if the first argument is a TypeBuffer object or not\n * @param {Object} obj The object to check against TypeBuffer.\n * @return {boolean}\n */\nType.prototype.isBuffer = function(obj) {\n  return obj instanceof TypeBuffer;\n}\n\n\n/**\n * Check if the first argument is a TypePoint object or not\n * @param {Object} obj The object to check against TypePoint.\n * @return {boolean}\n */\nType.prototype.isPoint = function(obj) {\n  return obj instanceof TypePoint;\n}\n\n\n/**\n * Check if the first argument is a TypeObject object or not\n * @param {Object} obj The object to check against TypeObject.\n * @return {boolean}\n */\nType.prototype.isObject = function(obj) {\n  return obj instanceof TypeObject;\n}\n\n\n/**\n * Check if the first argument is a TypeArray object or not\n * @param {Object} obj The object to check against TypeArray.\n * @return {boolean}\n */\nType.prototype.isArray = function(obj) {\n  return obj instanceof TypeArray;\n}\n\n\n/**\n * Check if the first argument is a TypeVirtual object or not\n * @param {Object} obj The object to check against TypeVirtual.\n * @return {boolean}\n */\nType.prototype.isVirtual = function(obj) {\n  return obj instanceof TypeVirtual;\n}\n\n\n/**\n * Check if the first argument is a TypeAny object or not\n * @param {Object} obj The object to check against TypeAny.\n * @return {boolean}\n */\nType.prototype.isAny = function(obj) {\n  return obj instanceof TypeAny;\n}\n\n\nmodule.exports = new Type();\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/type/any.js":"var util = require(__dirname+'/../util.js');\nvar schema =      require(__dirname+'/../schema.js');\n\nfunction TypeAny() {\n  this._default = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\nTypeAny.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n}\nTypeAny.prototype.validator = function(fn) {\n  this._validator = fn;\n}\nTypeAny.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n}\n\n// Dummy methods, just to allow users to easily switch from a valid type to any\nTypeAny.prototype.options = function(options) {\n  return this;\n}\nTypeAny.prototype.optional = function() {\n  return this;\n}\nTypeAny.prototype.required = function() {\n  return this;\n}\nTypeAny.prototype.allowNull = function() {\n  return this;\n}\nTypeAny.prototype.min = function() {\n  return this;\n}\nTypeAny.prototype.max = function() {\n  return this;\n}\nTypeAny.prototype.length = function() {\n  return this;\n}\nTypeAny.prototype.schema = function() {\n  return this;\n}\nTypeAny.prototype.validate = function() {\n  return this;\n}\n\nmodule.exports = TypeAny;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/type/array.js":"var util = require(__dirname+'/../util.js');\nvar schema =      require(__dirname+'/../schema.js');\nvar arrayPrefix = schema.arrayPrefix;\nvar Errors = require(__dirname+'/../errors.js');\n\nfunction TypeArray() {\n  this._min = -1;\n  this._max = -1;\n  this._length = -1;\n  this._schema = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\n\nTypeArray.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypeArray.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypeArray.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypeArray.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\nTypeArray.prototype.min = function(min) {\n  if (min < 0) {\n    throw new Errors.ValidationError(\"The value for `min` must be a positive integer\");\n  }\n  this._min = min;\n  return this;\n}\n\n\nTypeArray.prototype.max = function(max) {\n  if (max < 0) {\n    throw new Errors.ValidationError(\"The value for `max` must be a positive integer\");\n  }\n  this._max = max;\n  return this;\n}\n\n\nTypeArray.prototype.length = function(length) {\n  if (length < 0) {\n    throw new Errors.ValidationError(\"The value for `length` must be a positive integer\");\n  }\n  this._length = length;\n  return this;\n}\n\n\nTypeArray.prototype.schema = function(schema) {\n  this._schema = schema;\n  return this;\n}\n\n\nTypeArray.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypeArray.prototype.validator = function(fn) {\n  this._validator = fn;\n  return this;\n}\n\n\nTypeArray.prototype.validate = function(array, prefix, options) {\n  var self = this;\n  var localOptions = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(array, prefix, \"array\", localOptions)) return;\n\n  if ((typeof self._validator === \"function\") && (self._validator(array) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  if ((typeof array === 'function') && (array._query !== undefined)) {\n    // We do not check ReQL terms\n  }\n  else if (Array.isArray(array) === false) {\n    if (localOptions.enforce_type === \"strict\") {\n      util.strictType(prefix, \"array\");\n    }\n    else if ((localOptions.enforce_type === \"loose\") && (array !== null)) {\n      util.looseType(prefix, \"array\");\n    }\n  }\n  else {\n    if ((this._min !== -1) && (this._min > array.length)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must have at least \"+this._min+\" elements.\")\n    }\n    if ((this._max !== -1) && (this._max < array.length)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must have at most \"+this._max+\" elements.\")\n    }\n    if ((this._length !== -1) && (this._length !== array.length)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be an array with \"+this._length+\" elements.\")\n    }\n\n    for(var i=0; i<array.length; i++) {\n      if (array[i] === undefined) {\n        throw new Errors.ValidationError(\"The element in the array \"+prefix+\" (position \"+i+\") cannot be `undefined`.\");\n      }\n      if (this._schema !== undefined) {\n        this._schema.validate(array[i], prefix+\"[\"+i+\"]\", options);\n      }\n    }\n  }\n}\n\n\nTypeArray.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n  if (this._schema !== undefined) {\n    this._schema._getDefaultFields(prefix.concat(arrayPrefix), defaultFields, virtualFields);\n  }\n}\n\n\nmodule.exports = TypeArray;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/type/boolean.js":"var util = require(__dirname+'/../util.js');\nvar Errors = require(__dirname+'/../errors.js');\n\nfunction TypeBoolean() {\n  this._default = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\n\nTypeBoolean.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypeBoolean.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypeBoolean.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypeBoolean.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\n\nTypeBoolean.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypeBoolean.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n    this._validator = fn;\n  }\n  return this;\n}\n\n\nTypeBoolean.prototype.validate = function(bool, prefix, options) {\n  options = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(bool, prefix, \"boolean\", options)) return;\n\n  if ((typeof this._validator === \"function\") && (this._validator(bool) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  if (typeof bool !== \"boolean\") {\n    if (options.enforce_type === \"strict\") {\n      util.strictType(prefix, \"boolean\");\n    }\n    else if ((options.enforce_type === \"loose\") && (bool !== null)) {\n      util.looseType(prefix, \"boolean\");\n    }\n  }\n}\n\n\nTypeBoolean.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n}\n\n\nmodule.exports = TypeBoolean;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/type/buffer.js":"var util = require(__dirname+'/../util.js');\nvar Errors = require(__dirname+'/../errors.js');\n\nfunction TypeBuffer() {\n  this._default = undefined;\n  this._options = {};\n  this._validator = undefined;\n}\n\n\nTypeBuffer.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypeBuffer.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypeBuffer.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypeBuffer.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\nTypeBuffer.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypeBuffer.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n    this._validator = fn;\n  }\n  return this;\n}\n\n\nTypeBuffer.prototype.validate = function(buffer, prefix, options) {\n  options = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(buffer, prefix, \"buffer\", options)) return;\n\n  if ((typeof this._validator === \"function\") && (this._validator(buffer) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  if (util.isPlainObject(buffer) && (buffer[\"$reql_type$\"] === \"BINARY\")) {\n    if (buffer.data === undefined) {\n      util.pseudoTypeError(\"binary\", \"data\", prefix);\n    }\n  }\n  else if ((typeof buffer === 'function') && (buffer._query !== undefined)) {\n    // TOIMPROvE -- we currently just check if it's a term from the driver\n    // We suppose for now that this is enough and we don't throw an error\n  }\n  else if ((buffer instanceof Buffer) === false)  { // We don't have a buffer\n    if (options.enforce_type === \"strict\") {\n      util.strictType(prefix, \"buffer\");\n    }\n    else if ((options.enforce_type === \"loose\") && (buffer !== null)) {\n      util.looseType(prefix, \"buffer\");\n    }\n  }\n}\n\n\nTypeBuffer.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n}\n\n\nmodule.exports = TypeBuffer;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/type/date.js":"var util = require(__dirname+'/../util.js');\nvar Errors = require(__dirname+'/../errors.js');\n\nfunction TypeDate() {\n  this._min = undefined;\n  this._max = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\n\nTypeDate.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypeDate.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypeDate.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypeDate.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\nTypeDate.prototype.min = function(min) {\n  this._min = min;\n  return this;\n}\n\n\nTypeDate.prototype.max = function(max) {\n  this._max = max;\n  return this;\n}\n\n\nTypeDate.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypeDate.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n    this._validator = fn;\n  }\n  return this;\n}\n\n\nTypeDate.prototype.validate = function(date, prefix, options) {\n  options = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(date, prefix, \"date\", options)) return;\n\n  if ((typeof this._validator === \"function\") && (this._validator(date) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  var jsDate;\n  if (util.isPlainObject(date) && (date[\"$reql_type$\"] === \"TIME\")) {\n    if (date.epoch_time === undefined) {\n      util.pseudoTypeError(\"date\", \"epoch_time\", prefix);\n    }\n    else if (date.timezone === undefined) {\n      util.pseudoTypeError(\"date\", \"timezone\", prefix);\n    }\n\n    jsDate = new Date(0);\n    jsDate.setUTCSeconds(date.epoch_time)\n  }\n  else if ((typeof date === 'function') && (date._query !== undefined)) {\n    // TOIMPROVE -- we currently just check if it's a term from the driver\n    // We suppose for now that this is enough and we don't throw an error\n  }\n  else if (typeof date === 'string' || typeof date === 'number') {\n    var numericDate = parseInt(date, 10);\n    if(!isNaN(numericDate)){\n      date = numericDate;\n    }\n    jsDate = new Date(date);\n    if (jsDate.getTime() !== jsDate.getTime()) {\n      if (options.enforce_type === \"strict\") {\n        util.strictType(prefix, \"date or a valid string\");\n      }\n      else if (options.enforce_type !== \"none\") {\n        util.looseType(prefix, \"date or a valid string\");\n      }\n    }\n  }\n  else if ((date instanceof Date) === false) { // We have a non valid date\n    if (options.enforce_type === \"strict\") {\n      util.strictType(prefix, \"date\");\n    }\n    else if ((options.enforce_type === \"loose\") && (date !== null)) {\n      util.looseType(prefix, \"date\");\n    }\n  }\n  else {\n    jsDate = date;\n  }\n\n  // We check for min/max only if we could create a javascript date from the value\n  if (jsDate !== undefined) {\n    if ((this._min instanceof Date) && (this._min > jsDate)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be after \"+this._min+\".\")\n    }\n    if ((this._max instanceof Date) && (this._max < jsDate)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be before \"+this._max+\".\")\n    }\n  }\n}\n\n\nTypeDate.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n}\n\n\nmodule.exports = TypeDate;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/type/number.js":"var util = require(__dirname+'/../util.js');\nvar Errors = require(__dirname+'/../errors.js');\n\nfunction TypeNumber() {\n  this._min = undefined;\n  this._max = undefined;\n  this._integer = false;\n  this._default = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\n\nTypeNumber.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypeNumber.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypeNumber.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypeNumber.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\n\nTypeNumber.prototype.min = function(min) {\n  if ((typeof(min) !== 'number') || (isFinite(min) == false)) {\n    throw new Errors.ValidationError(\"The value for `min` must be a finite number\");\n  }\n  this._min = min;\n  return this;\n}\n\n\nTypeNumber.prototype.max = function(max) {\n  if ((typeof(max) !== 'number') || (isFinite(max) == false)) {\n    throw new Errors.ValidationError(\"The value for `max` must be a finite number\");\n  }\n  this._max = max;\n  return this;\n}\n\n\nTypeNumber.prototype.integer = function() {\n  this._integer = true;\n  return this;\n}\n\n\nTypeNumber.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypeNumber.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n    this._validator = fn;\n  }\n  return this;\n}\n\n\nTypeNumber.prototype.validate = function(number, prefix, options) {\n  options = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(number, prefix, \"number\", options)) return;\n\n  if ((typeof this._validator === \"function\") && (this._validator(number) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  if(typeof number === 'string'){\n    var numericString = parseFloat(number);\n    if(!isNaN(numericString)){\n      number = numericString;\n    }\n  }\n\n  if ((typeof number === 'function') && (number._query !== undefined)) {\n    // We do not check ReQL terms\n  }\n  else if ((typeof number !== \"number\") || (isFinite(number) === false)) {\n    if (options.enforce_type === \"strict\") {\n      util.strictType(prefix, \"finite number\");\n    }\n    else if ((options.enforce_type === \"loose\") && (number !== null)) {\n      util.looseType(prefix, \"finite number\");\n    }\n  }\n  else {\n    if ((this._min !== undefined) && (this._min > number)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be greater than or equal to \"+this._min+\".\")\n    }\n    if ((this._max !== undefined) && (this._max < number)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be less than or equal to \"+this._max+\".\")\n    }\n    if ((this._integer === true) && (number % 1 !== 0)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be an integer.\")\n    }\n  }\n}\n\n\nTypeNumber.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n}\n\n\nmodule.exports = TypeNumber;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/type/object.js":"var util = require(__dirname+'/../util.js');\nvar Errors = require(__dirname+'/../errors.js');\n\nfunction TypeObject() {\n  this._default = undefined;\n  this._validator = undefined;\n  this._options = {};\n  this._schema = {};\n}\n\n\nTypeObject.prototype._setModel = function(model) {\n  this._model = model;\n  return this;\n}\n\n\nTypeObject.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypeObject.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypeObject.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypeObject.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\nTypeObject.prototype.allowExtra = function(allowed) {\n  if (allowed === true) {\n    this._options.enforce_extra = 'none';\n  }\n  else if (allowed === false) {\n    this._options.enforce_extra = 'strict';\n  }\n  return this;\n}\n\n\nTypeObject.prototype.removeExtra = function() {\n  this._options.enforce_extra = 'remove';\n  return this;\n}\n\n\nTypeObject.prototype.schema = function(schema) {\n  // Users shouldn't use the deprecated syntax with the chainable one\n  // We do not parse the schema as we don't have the current prefix, options etc.\n  this._schema = schema;\n  return this;\n}\n\n\nTypeObject.prototype.setKey = function(key, schema) {\n  this._schema[key] = schema;\n  return this;\n}\n\n\nTypeObject.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypeObject.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n    this._validator = fn;\n  }\n  return this;\n}\n\n\nTypeObject.prototype.validate = function(object, prefix, options) {\n  var self = this;\n  var localOptions = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(object, prefix, \"object\", localOptions)) return;\n\n  if ((typeof self._validator === \"function\") && (self._validator(object) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  if ((typeof object === 'function') && (object._query !== undefined)) {\n    // We do not check ReQL terms\n  }\n  else if (util.isPlainObject(object) === false) {\n    if (localOptions.enforce_type === \"strict\") {\n      util.strictType(prefix, \"object\");\n    }\n    else if ((localOptions.enforce_type === \"loose\") && (object !== null)) {\n      util.looseType(prefix, \"object\");\n    }\n  }\n  else {\n    util.loopKeys(self._schema, function(schema, key) {\n      schema[key].validate(object[key], prefix+\"[\"+key+\"]\", options);\n    });\n\n    // We clean extra fields in validate, for a use case, see:\n    // https://github.com/neumino/thinky/pull/123#issuecomment-56254682\n    if (localOptions.enforce_extra === \"remove\") {\n      util.loopKeys(object, function(object, key) {\n        if ((self._model === undefined || self._model._joins.hasOwnProperty(key) === false)\n            && (self._schema[key] === undefined)) {\n          delete object[key];\n        }\n      });\n    }\n    else if (localOptions.enforce_extra === \"strict\") {\n      util.loopKeys(object, function(object, key) {\n        if ((self._model === undefined || self._model._joins.hasOwnProperty(key) === false)\n            && (self._schema[key] === undefined)) {\n          util.extraField(prefix, key);\n        }\n      });\n    }\n  }\n}\n\n\nTypeObject.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n  if (this._schema !== undefined) {\n    util.loopKeys(this._schema, function(_schema, key) {\n      if (typeof _schema[key]._getDefaultFields !== 'function') {\n        console.log(_schema);\n        console.log(key);\n        console.log(_schema[key]);\n      }\n      _schema[key]._getDefaultFields(prefix.concat(key), defaultFields, virtualFields);\n    })\n  }\n}\n\n\nmodule.exports = TypeObject;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/type/point.js":"var util = require(__dirname+'/../util.js');\nvar Errors = require(__dirname+'/../errors.js');\n\nfunction TypePoint() {\n  this._default = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\n\nTypePoint.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\nTypePoint.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\nTypePoint.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\nTypePoint.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\nTypePoint.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\nTypePoint.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n   this._validator = fn;\n  }\n  return this;\n}\n\n\nTypePoint.prototype.validate = function(point, prefix, options) {\n  options = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(point, prefix, \"point\", options)) return;\n\n  if ((typeof this._validator === \"function\") && (this._validator(point) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n  if (util.isPlainObject(point) && (point[\"$reql_type$\"] === \"GEOMETRY\")) {\n    if (point.type === undefined) {\n      util.pseudoTypeError(\"Point\", \"type\", prefix);\n    }\n    else if (point.type !== \"Point\") {\n      throw new Errors.ValidationError(\"The field `type` for \"+prefix+\" must be `'Point'`.\")\n    }\n    else if (point.coordinates === undefined) {\n      util.pseudoTypeError(\"date\", \"coordinates\", prefix);\n    }\n    else if ((!Array.isArray(point.coordinates)) || (point.coordinates.length !== 2)) {\n      throw new Errors.ValidationError(\"The field `coordinates` for \"+prefix+\" must be an Array of two numbers.\")\n    }\n  }\n  else if (util.isPlainObject(point) && (point.type === \"Point\") && (Array.isArray(point.coordinates)) && (point.coordinates.length === 2)) { // Geojson\n    // Geojson format\n  }\n  else if ((typeof point === 'function') && (point._query !== undefined)) {\n    // TOIMPROvE -- we currently just check if it's a term from the driver\n    // We suppose for now that this is enough and we don't throw an error\n  }\n  else if (util.isPlainObject(point)) {\n    var keys = Object.keys(point).sort();\n    if (((keys.length !== 2) || keys[0] !== 'latitude') || (keys[1] !== 'longitude') || (typeof point.latitude !== \"number\") || (typeof point.longitude !== \"number\")) {\n      throw new Errors.ValidationError(\"The value for \"+prefix+\" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].\")\n    }\n    else if ((typeof point.latitude !== 'number') || (typeof point.latitude !== 'number')) {\n      throw new Errors.ValidationError(\"The value for \"+prefix+\" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].\")\n    }\n  }\n  else if (Array.isArray(point)) {\n    if ((point.length !== 2) || (typeof point[0] !== \"number\") || (typeof point[1] !== \"number\")) {\n      throw new Errors.ValidationError(\"The value for \"+prefix+\" must be a ReQL Point (`r.point(<longitude>, <latitude>)`), an object `{longitude: <number>, latitude: <number>}`, or an array [<longitude>, <latitude>].\")\n    }\n  }\n  else { // We don't have a point\n    if (options.enforce_type === \"strict\") {\n      util.strictType(prefix, \"Point\");\n    }\n    else if ((options.enforce_type === \"loose\") && (point !== null)) {\n      util.looseType(prefix, \"Point\");\n    }\n  }\n}\n\n\nTypePoint.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n}\n\nmodule.exports = TypePoint;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/type/string.js":"var util =       require(__dirname+'/../util.js');\nvar validator =  require(\"validator\");\nvar Errors = require(__dirname+'/../errors.js');\n\n/**\n * Create a new TypeString object\n */\nfunction TypeString() {\n  /**\n   * Minimum length of the string, negative if no minimum length is required.\n   * @type {number}\n   */\n  this._min = -1;\n  /**\n   * Maximum length of the string, negative if no maximum length is required.\n   * @type {number}\n   */\n  this._max = -1;\n  /**\n   * Length of the string, negative if no length is required.\n   * @type {number}\n   */\n  this._length = -1;\n  /**\n   * Whether the string must be alphanumeric or not. We used the npm validator\n   * package, and as 2014/12/14, it check against the regex [a-zA-Z0-9]\n   * @type {boolean}\n   */\n  this._alphanum = false;\n  /**\n   * Whether this string must be uppercase or not.\n   * @type {boolean}\n   */\n  this._uppercase = false;\n  /**\n   * Whether this string must be lowercase or not.\n   * @type {boolean}\n   */\n  this._lowercase = false;\n  /*\n   * The regex against which the string must conform. Undefined if the string\n   * does not have to conform to a RegExp.\n   * @type {RegExp=}\n   */\n  this._regex = undefined;\n  /**\n   * The validator called with the string must return {true} if the string is valid,\n   * {false} if the string is not.\n   * @type {function(string)=}\n   */\n  this._enum = undefined;\n  /**\n   * The default value for this field or a function to generate the default value.\n   * @type {function|string}\n   */\n  this._default = undefined;\n  /**\n   * Whether this string must be a uuid or not.\n   * @type {number}\n   */\n  this._uuid = undefined;\n  /**\n   * Options for this type \"enforce_missing\", \"enforce_type\", \"enforce_extra\"\n   * @type {Object=}\n   */\n  this._validator = undefined;\n  /**\n   * An object whose keys are the acceptable values for the string. Undefined if this\n   * is not a requirement.\n   * @type {Object=}\n   */\n  this._options = {};\n}\n\n\n/**\n * Set the options for this field.\n * @param {!object} options The options for this field. The valid fields are:\n *  - `enforce_missing` {boolean}, default `false`\n *  - `enforce_extra` {\"strict\"|\"remove\"|\"none\"}, default `\"none\"`\n *  - `enforce_type` {\"strict\"|\"loose\"|\"none\"}, default `\"loose\"`\n * @return {TypeString}\n */\nTypeString.prototype.options = function(options) {\n  if (util.isPlainObject(options)) {\n    if (options.enforce_missing != null) {\n      this._options.enforce_missing =  options.enforce_missing\n    }\n    if (options.enforce_type != null) {\n      this._options.enforce_type = options.enforce_type;\n    }\n    if (options.enforce_extra != null) {\n      this._options.enforce_extra = options.enforce_extra\n    }\n  }\n  return this;\n}\n\n\n/**\n * Set the property as optional (enforce_missing = false).\n * Leaves other existing options unchanged.\n * @return {TypeString}\n */\nTypeString.prototype.optional = function() {\n  this._options.enforce_missing = false;\n  return this;\n}\n\n\n/**\n * Set the property as required (enforce_missing = true).\n * Leaves other existing options unchanged.\n * @return {TypeString}\n */\nTypeString.prototype.required = function() {\n  this._options.enforce_missing = true;\n  return this;\n}\n\n\n/**\n * Set the property as not strict (null allowed, enforce_missing = true).\n * Leaves other existing options unchanged.\n * @return {TypeString}\n */\nTypeString.prototype.allowNull = function(value) {\n  if (this._options.enforce_type === 'strict') {\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    // else a no-op, strict -> strict\n  }\n  else if (this._options.enforce_type !== 'none') {\n    // The value is loose or undefined\n    if (value === true) {\n      this._options.enforce_type = 'loose'\n    }\n    else {\n      // The default value is loose, so if we call allowNull(false), it becomes strict\n      this._options.enforce_type = 'strict'\n    }\n  }\n  // else no op, type.any() is the same as type.any().allowNull(<bool>)\n  return this;\n}\n\n\n/**\n * Set the minimum length allowed for a string.\n * @param {number} min Minimum length for the string\n * @return {TypeString}\n */\nTypeString.prototype.min = function(min) {\n  if (min < 0) {\n    throw new Errors.ValidationError(\"The value for `min` must be a positive integer\");\n  }\n  this._min = min;\n  return this;\n}\n\n\n/**\n * Set the maximum length allowed for a string.\n * @param {number} min Minimum length for the string\n * @return {TypeString}\n */\nTypeString.prototype.max = function(max) {\n  if (max < 0) {\n    throw new Errors.ValidationError(\"The value for `max` must be a positive integer\");\n  }\n  this._max = max;\n  return this;\n}\n\n\n/**\n * Set the length allowed for a string.\n * @param {number} min Minimum length for the string\n * @return {TypeString}\n */\nTypeString.prototype.length = function(length) {\n  if (length < 0) {\n    throw new Errors.ValidationError(\"The value for `length` must be a positive integer\");\n  }\n  this._length = length;\n  return this;\n}\n\n\n/**\n * Set the regex that the string must match.\n * @param {string} regex The string representation of the regex\n * @param {string} flags The flags used when calling new RegExp(...)\n * @return {TypeString}\n */\nTypeString.prototype.regex = function(regex, flags) {\n  if (typeof flags === \"string\") {\n    this._regex = new RegExp(regex, flags);\n  }\n  else {\n    this._regex = new RegExp(regex);\n  }\n  return this;\n}\n\n\n/**\n * Set the string to be alphanumeric.\n * @return {TypeString}\n */\nTypeString.prototype.alphanum = function() {\n  this._alphanum = true;\n  return this;\n}\n\n\n/**\n * Set the string to be an email.\n * @return {TypeString}\n */\nTypeString.prototype.email = function() {\n  this._email = true;\n  return this;\n}\n\n\n/**\n * Set the string to be lowercase.\n * @return {TypeString}\n */\nTypeString.prototype.lowercase = function() {\n  this._lowercase = true;\n  return this;\n}\n\n\n/**\n * Set the string to be uppercase.\n * @return {TypeString}\n */\nTypeString.prototype.uppercase = function() {\n  this._uppercase = true;\n  return this;\n}\n\n\n/**\n * Set the default value for this string, or the function that will generate\n * the default value\n * @param {string|function} fnOrValue\n * @return {TypeString}\n */\nTypeString.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n/**\n * Set the string to be a uuid.\n * @param {number} version\n * @return {TypeString}\n */\nTypeString.prototype.uuid = function(version) {\n  if (isNaN(version)) {\n    throw new Errors.ValidationError(\"The value for `version` must be a number.\");\n  }\n  if (version < 3 || version > 5) {\n    throw new Errors.ValidationError(\"The value for `version` must be either 3, 4 or 5\");\n  }\n  this._uuid = version;\n  return this;\n}\n\n\n/**\n * Set a custom validator that will be called with the string. The validator\n * should return a boolean whether the field is valid or not.\n * @param {function} fn\n * @return {TypeString}\n */\nTypeString.prototype.validator = function(fn) {\n  if (typeof fn === \"function\") {\n    this._validator = fn;\n  }\n  return this;\n}\n\n\n/**\n * Set the valid values for this field. The arguments must be strings\n * or an array of strings.\n * @param {...string|Array.<string>} fn\n * @return {TypeString}\n */\nTypeString.prototype.enum = function() {\n  if ((arguments.length === 1) && (Array.isArray(arguments[0]))) {\n    this._enum = {};\n    for(var i=0; i<arguments[0].length; i++) {\n      this._enum[arguments[0][i]] = true;\n    }\n  }\n  else if ((arguments.length !== 1) || (arguments[0] !== undefined)) {\n    this._enum = {};\n    for(var i=0; i<arguments.length; i++) {\n      this._enum[arguments[i]] = true;\n    }\n  }\n  return this;\n}\n\n\n/**\n * Validate the string given optional options, and throw an error in case\n * the field is not valid.\n * @param {string} str The string to validate.\n * @param {string} prefix The prefix leading to `str`.\n * @param {object=} options Options to overwrite the one defined for the field.\n * @throws {Error}\n */\nTypeString.prototype.validate = function(str, prefix, options) {\n  var _options = util.mergeOptions(this._options, options);\n\n  if (util.validateIfUndefined(str, prefix, \"string\", _options)) return;\n\n  if ((typeof this._validator === \"function\") && (this._validator(str) === false)) {\n    throw new Errors.ValidationError(\"Validator for the field \"+prefix+\" returned `false`.\");\n  }\n\n\n  if ((typeof str === 'function') && (str._query !== undefined)) {\n    // We do not check ReQL terms\n  }\n  else if (typeof str !== \"string\") {\n    if (_options.enforce_type === \"strict\") {\n      util.strictType(prefix, \"string\");\n    }\n    else if ((_options.enforce_type === \"loose\") && (str !== null)) {\n      util.looseType(prefix, \"string\");\n    }\n  }\n  else {\n    if ((this._min !== -1) && (this._min > str.length)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must not be shorter than \"+this._min+\".\")\n    }\n    if ((this._max !== -1) && (this._max < str.length)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must not be longer than \"+this._max+\".\")\n    }\n    if ((this._length !== -1) && (this._length !== str.length)){\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a string with \"+this._length+\" characters.\")\n    }\n    if ((this._regex instanceof RegExp) && (this._regex.test(str) === false)) {\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must match the regex.\")\n    }\n    if ((this._alphanum === true) && (validator.isAlphanumeric(str) === false)) {\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be an alphanumeric string.\")\n    }\n    if ((this._email === true) && (validator.isEmail(str) === false)) {\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a valid email.\")\n    }\n    if ((this._lowercase === true) && (validator.isLowercase(str) === false)) {\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a lowercase string.\")\n    }\n    if ((this._uppercase === true) && (validator.isUppercase(str) === false)) {\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a uppercase string.\")\n    }\n    if ((this._uuid !== undefined) && (validator.isUUID(str, this._uuid) === false)) {\n      throw new Errors.ValidationError(\"Value for \"+prefix+\" must be a uuid string.\")\n    }\n    if ((this._enum !== undefined) && (this._enum[str] !== true)) {\n      var validValues = Object.keys(this._enum);\n      var message = \"The field \"+prefix+\" must be one of these values: \"\n\n      for(var i=0; i<validValues.length; i++) {\n        if (i === 10) { break; }\n        if ((i === validValues.length-1) || (i === 9)) {\n          message = message+validValues[i]\n        }\n        else {\n          message = message+validValues[i]+\", \"\n        }\n      }\n      if (validValues.length > 10) {\n        message = message+\"...\"\n      }\n      else {\n        message = message+\".\"\n      }\n\n      throw new Errors.ValidationError(message);\n    }\n  }\n}\n\n\n/**\n * Look for a default value or default function, and append an object to `defaultFields`.\n * @param {string} prefix The prefix leading to `str`.\n * @param {Array.<Object>} defaultFields The default fields to generate\n * @param {Array.<Object>} virtualFields The virtual fields to generate\n * @return {TypeString}\n */\nTypeString.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  if (this._default !== undefined) {\n    defaultFields.push({\n      path: prefix,\n      value: this._default,\n    });\n  }\n  return this;\n}\n\n\nmodule.exports = TypeString;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/type/virtual.js":"function TypeVirtual() {\n  this._default = undefined;\n  this._validator = undefined;\n  this._options = {};\n}\n\n\nTypeVirtual.prototype.default = function(fnOrValue) {\n  this._default = fnOrValue;\n  return this;\n}\n\n\n// Dummy functions\nTypeVirtual.prototype.validate = function() {}\n\n\nTypeVirtual.prototype.options = function() {}\n\n\nTypeVirtual.prototype.optional = function() {}\n\n\nTypeVirtual.prototype.required = function() {}\n\n\nTypeVirtual.prototype.allowNull = function() {}\n\n\nTypeVirtual.prototype._getDefaultFields = function(prefix, defaultFields, virtualFields) {\n  // We keep track of virtual fields even if there is no default value\n  virtualFields.push({\n    path: prefix,\n    value: this._default,\n  });\n}\n\nmodule.exports = TypeVirtual;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/document.js":"var schemaUtil =    require(__dirname+'/schema.js');\nvar type =          require(__dirname+'/type/index.js');\nvar util =          require(__dirname+'/util.js');\nvar Promise =       require('bluebird');\nvar EventEmitter =  require('events').EventEmitter;\nvar Errors =        require(__dirname+'/errors.js');\n\n\n/**\n * Create a document of a model (returned by `thinky.createModel`).\n * @param {function} model The model of this document\n * @param {object=} options Options that can overwrite the ones of the model\n */\nfunction Document(model, options) {\n  var self = this;  // Keep a reference to itself.\n\n  this.constructor = model;  // The constructor for this model\n  this._model = model._getModel(); // The instance of Model\n\n  // We don't want to store options if they are different\n  // than the one provided by the model\n  if (util.isPlainObject(options)) {\n    this._schemaOptions = {};\n    this._schemaOptions.enforce_missing =\n        (options.enforce_missing != null) ? options.enforce_missing : model.getOptions().enforce_missing;\n    this._schemaOptions.enforce_extra =\n        (options.enforce_extra != null) ? options.enforce_extra : model.getOptions().enforce_extra;\n    this._schemaOptions.enforce_type =\n        (options.enforce_type != null) ? options.enforce_type : model.getOptions().enforce_type;\n  }\n\n  //TODO: We do not need to make a deep copy. We can do the same as for this._schemaOptions.\n  options = options || {};\n  this._options = {};\n  this._options.timeFormat = (options.timeFormat != null) ? options.timeFormat : model.getOptions().timeFormat;\n  this._options.validate = (options.validate != null) ? options.validate : model.getOptions().validate;\n\n  this._saved = options.saved || false;  // Whether the document is saved or not\n\n  util.bindEmitter(self);  // Copy methods from eventEmitter\n\n  // links to hasOne/hasMany documents\n  // We use it to know if some links have been removed/added before saving.\n  // Example: { key: doc } or { key: [docs] }\n  this._belongsTo = {};\n  this._hasOne = {};\n  this._hasMany = {};\n  // Example: { <linkTableName>: { <valueOfRightKey>: true, ... }, ... }\n  this._links = {}\n\n  // Keep reference of any doc having a link pointing to this\n  // So we can clean when users do doc.belongsToDoc.delete()\n  this._parents = {\n    _hasOne: {},      // <tableName>: [{doc, key}]\n    _hasMany: {},     // <tableName>: [{doc, key}]\n    _belongsTo: {},   // <tableName>: [{doc, key, foreignKey}]\n    _belongsLinks: {} // <tableName>: [{doc, key}]\n  }\n\n  // Bind listeners of the model to this documents.\n  util.loopKeys(model._listeners, function(listeners, eventKey) {\n    for(var j=0; j<listeners[eventKey].length; j++) {\n      if (listeners[eventKey][j].once === false) {\n        self.addListener(eventKey, listeners[eventKey][j].listener);\n      }\n      else if (listeners[eventKey][j].once === true) {\n        self.once(eventKey, listeners[eventKey][j].listener);\n      }\n    }\n  });\n\n\n  // Atom feed\n  this._active = false;\n  this._feed = null;\n\n  // Add customized methods of the model on this document.\n  util.loopKeys(model._methods, function(methods, key) {\n    if (self[key] === undefined) {\n      self[key] = methods[key];\n    }\n    else {\n      //TODO: Should we warn the users? Throw an error?\n      console.log(self[key]);\n      console.log(\"A property \"+key+\" is already defined in the prototype chain. Skipping.\");\n    }\n  });\n}\n\n\n/**\n * Return the options of the document, not the instance of Document.\n * @return {Object=}\n */\nDocument.prototype._getOptions = function() {\n  return this.__proto__._options;\n}\n\n\n/**\n * Return the options for the schema of the document, not the instance of Document.\n * @return {Object=}\n */\nDocument.prototype._getSchemaOptions = function() {\n  return this.__proto__._schemaOptions;\n}\n\n\n/**\n * Return the constructor of the document, not the instance of Document.\n * @return {function}\n */\nDocument.prototype.getModel = function() {\n  return this.__proto__.constructor;\n}\n\n\n/**\n * Return the model, the instance of Model\n * @return {function}\n */\nDocument.prototype._getModel = function() {\n  return this.__proto__._model;\n}\n\n\n/**\n * Save the virtual fields of the document to be re-injected later.\n */\nDocument.prototype._saveVirtual = function() {\n  var copy = {};\n  var model = this._getModel(); // instance of Model\n\n  // TODO We could do better and copy less things, but things get a bit tricky\n  // when virtual fields are nested in arrays.\n  // This implementation still allows no overhead if no virtual fields exist,\n  // which should be the most common case\n  for(var i=0; i<this._getModel().virtualFields.length; i++) {\n    var key = this._getModel().virtualFields[i].path[0];\n    copy[key] = this[key];\n  }\n  this.__proto__.virtualValue = util.deepCopy(copy);\n}\n\n\n/**\n * Get the virtual fields saved by `_saveVirtual`.\n * @return {Object=}\n */\nDocument.prototype._getVirtual = function() {\n  return this.__proto__.virtualValue;\n}\n\n/**\n * Generate the virtual values for the document, or re-inject the ones\n * previously saved.\n * This should be called **after** `_generateDefault`.\n */\nDocument.prototype.generateVirtualValues = function() {\n  for(var i=0; i<this._getModel().virtualFields.length; i++) {\n    schemaUtil.generateVirtual(this, this._getModel().virtualFields[i], this, this._getVirtual());\n  }\n}\n\n\n/**\n * Generate the default values for the document, first the non virtual fields, and then\n * the virtual fields.\n */\nDocument.prototype._generateDefault = function() {\n  for(var i=0; i<this._getModel().defaultFields.length; i++) {\n    schemaUtil.generateDefault(this, this._getModel().defaultFields[i], this);\n  }\n  if (this._getModel().virtualFields.length > 0) {\n    this.generateVirtualValues();\n  }\n}\n\n\n/*\n * Validate this document against the schema of its model and triggers all the hooks.\n * @param {Object=} options Options to overwrite the ones of the document.\n * @param {Object=} modelToValidate Internal parameter, model to validate\n * @param {boolean=} validateAll Internal parameter, Option to keep recursing as long as no non-circular model have been found.\n * @param {Object=} validatedModel Internal parameter, All the models for which we already validated at least one document.\n * @param {string=} prefix Internal parameter, The current path to this path (used in case of joined documents).\n * @return {Promise=} return a promise if the validation is asynchrone, else undefined.\n */\nDocument.prototype.validate = function(options, modelToValidate, validateAll, validatedModel, prefix) {\n  modelToValidate = modelToValidate || {};\n  validateAll = validateAll || false;\n  validatedModel = validatedModel || {};\n  prefix = prefix || '';\n\n  var self = this;\n  var validatedModelCopy = util.deepCopy(validatedModel);\n\n  //TODO: Can we not always call this?\n  var async = self._validateIsAsync(modelToValidate, validateAll, validatedModelCopy);\n\n  return util.hook({\n    preHooks: self._getModel()._pre.validate,\n    postHooks: self._getModel()._post.validate,\n    doc: self,\n    async: async,\n    fn: self._validateHook,\n    fnArgs: [options, modelToValidate, validateAll, validatedModel, prefix]\n  })\n}\n\n\n/*\n * Validate this document against the schema of its model and all its joined documents and triggers all the hooks\n * @param {Object=} options Options to overwrite the ones of the document.\n * @param {Object=} modelToValidate Internal parameter, model to validate\n * @return {Promise=} return a promise if the validation is asynchrone, else undefined.\n */\nDocument.prototype.validateAll = function(options, modelToValidate) {\n  var validateAll = modelToValidate === undefined;\n  modelToValidate = modelToValidate || {};\n\n  return this.validate(options, modelToValidate, validateAll, {}, '', true);\n}\n\n\n/*\n * Internal methods that will validate the document (but that will not execute the hooks).\n * @param {Object=} options Options to overwrite the ones of the document.\n * @param {Object=} modelToValidate Internal parameter, model to validate\n * @param {boolean=} validateAll Internal parameter, Option to keep recursing as long as no non-circular model have been found.\n * @param {Object=} validatedModel Internal parameter, All the models for which we already validated at least one document.\n * @param {string=} prefix Internal parameter, The current path to this path (used in case of joined documents).\n * @return {Promise=} return a promise if the validation is asynchrone, else undefined.\n */\nDocument.prototype._validateHook = function(options, modelToValidate, validateAll, validatedModel, prefix) {\n  var self = this;\n  var promises = [];\n  var error;\n\n  var schemaOptions = self._getSchemaOptions();\n  if (util.isPlainObject(schemaOptions)) {\n    schemaOptions = util.mergeOptions(schemaOptions, options);\n  }\n  else {\n    schemaOptions = options;\n  }\n\n\n  if (typeof self._getModel()._validator === 'function') {\n    if (self._getModel()._validator.call(self, self) === false) {\n      throw new Errors.ValidationError(\"Document's validator returned `false`.\");\n    }\n  }\n\n  // Validate this document\n  self._getModel()._schema.validate(self, prefix, schemaOptions)\n\n  if (util.isPlainObject(modelToValidate) === false) {\n    modelToValidate = {};\n  }\n\n  var constructor = self.__proto__.constructor;\n  validatedModel[constructor.getTableName()] = true;\n\n  // Validate joined documents\n  util.loopKeys(self._getModel()._joins, function(joins, key) {\n    if (util.recurse(key, joins, modelToValidate, validateAll, validatedModel)) {\n      switch (joins[key].type) {\n        case 'hasOne':\n        case 'belongsTo':\n          if (util.isPlainObject(self[key])) {\n            if (self[key] instanceof Document === false) {\n              self[key] = new self._getModel()._joins[key].model(self[key]);\n            }\n            // We do not propagate the options of this document, but only those given to validate\n            var promise = self[key].validate(options, modelToValidate[key], validateAll, validatedModel, prefix+'['+key+']');\n            if (promise instanceof Promise) {\n              promises.push(promise);\n              promise = null;\n            }\n          }\n          else if (self[key] != null) {\n            throw new Errors.ValidationError(\"Joined field \"+prefix+\"[\"+key+\"] should be `undefined`, `null` or an `Object`\")\n          }\n          break;\n\n        case 'hasMany':\n        case 'hasAndBelongsToMany':\n          if (Array.isArray(self[key])) {\n            for(var i=0; i<self[key].length; i++) {\n              if (util.isPlainObject(self[key][i])) {\n                if (self[key][i] instanceof Document === false) {\n                  self[key][i] = new self._getModel()._joins[key].model(self[key][i]);\n                }\n                promise = self[key][i].validate(options, modelToValidate[key], validateAll, validatedModel, prefix+'['+key+']['+i+']');\n                if (promise instanceof Promise) {\n                  promises.push(promise);\n                  promise = null;\n                }\n              }\n              else {\n                throw new Errors.ValidationError(\"Joined field \"+prefix+\"[\"+key+\"][\"+i+\"] should be `undefined`, `null` or an `Array`\")\n              }\n            }\n          }\n          else if (self[key] != null) {\n            throw new Errors.ValidationError(\"Joined field \"+prefix+\"[\"+key+\"] should be `undefined`, `null` or an `Array`\")\n          }\n          break;\n      }\n    }\n  });\n  if (promises.length > 0) {\n    return Promise.all(promises);\n  }\n}\n\n\n/*\n * Return whether the validation run with the same options will be asynchronous or not.\n * @param {Object=} modelToValidate Internal parameter, model to validate\n * @param {boolean=} validateAll Internal parameter, Option to keep recursing as long as no non-circular model have been found.\n * @param {Object=} validatedModel Internal parameter, All the models for which we already validated at least one document.\n * @return {boolean}\n */\nDocument.prototype._validateIsAsync = function(modelToValidate, validateAll, validatedModel) {\n  var self = this;\n\n  if (self._getModel()._async.validate) {\n    return true;\n  }\n  var async = false;\n  util.loopKeys(self._getModel()._joins, function(joins, key) {\n    if (util.recurse(key, joins, modelToValidate, validateAll, validatedModel)) {\n      if (((joins[key].type === 'hasOne') || (joins[key].type === 'belongsTo'))) {\n        if (util.isPlainObject(self[key])) {\n          if (self[key] instanceof Document === false) {\n            self[key] = new self._getModel()._joins[key].model(self[key]);\n          }\n          // We do not propagate the options of this document, but only those given to validate\n          if (self[key]._getModel()._async.validate || self[key]._validateIsAsync(modelToValidate, validateAll, validatedModel)) {\n            async = true;\n            return false;\n          }\n        }\n      }\n      else  if (((joins[key].type === 'hasMany') || (joins[key].type === 'hasAndBelongsToMany'))) {\n        if (Array.isArray(self[key])) {\n          for(var i=0; i<self[key].length; i++) {\n            if (util.isPlainObject(self[key][i])) {\n              if (self[key][i] instanceof Document === false) {\n                self[key][i] = new self._getModel()._joins[key].model(self[key][i]);\n              }\n              if (self[key][i]._getModel()._async.validate || self[key][i]._validateIsAsync(modelToValidate, validateAll, validatedModel)) {\n                async = true;\n                return false;\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  });\n  return async;\n}\n\n\n/**\n * Save the document and execute the hooks. Return a promise if the callback\n * is not provided.\n * @param {function=} callback to execute\n * @return {Promise=}\n */\nDocument.prototype.save = function(callback) {\n  return this._save({}, false, {}, callback);\n}\n\n\n/**\n * Save the document and its joined documents. It will also execute the hooks.\n * Return a promise if the callback is not provided.\n * It will save joined documents as long as a document of the same model has not\n * been saved.\n * @param {function=} callback to execute\n * @return {Promise=}\n */\nDocument.prototype.saveAll = function(docToSave, callback) {\n  var saveAll;\n  if (typeof docToSave === 'function') {\n    callback = docToSave;\n    saveAll = true;\n    docToSave = {};\n  }\n  else {\n    saveAll = docToSave === undefined;\n    docToSave = docToSave || {};\n  }\n\n  return this._save(docToSave, saveAll,{}, callback);\n}\n\n\n/**\n * Return a savable copy of the document by removing the extra fields,\n * generating the default and virtual fields.\n * @return {object}\n */\nDocument.prototype._makeSavableCopy = function() {\n  var model = this._getModel(); // instance of Model\n  var schema = this._getModel()._schema;\n\n  var r = this._getModel()._thinky.r;\n\n  if (this._getModel().needToGenerateFields === true){\n    this._generateDefault();\n  }\n\n  return this.__makeSavableCopy(this, schema, this._getOptions(), model, r)\n}\n\n\n/**\n * Internal helper for _makeSavableCopy.\n * generating the dfault and virtual fields.\n * @return {any} the copy of the field/object.\n */\nDocument.prototype.__makeSavableCopy = function(doc, schema, options, model, r) {\n  var localOptions; // can be undefined\n  if (schema !== undefined) {\n    localOptions = schema._options;\n  }\n\n  // model is an instance of a Model (for the top level fields), or undefined\n  var result, key, keys, nextSchema, copyFlag;\n  if (type.isDate(schema) && (typeof doc === 'string' || typeof doc === 'number')) {\n    if (typeof doc === 'number') {\n      var numericDate = parseInt(doc, 10);\n      if(!isNaN(numericDate)) {\n        doc = numericDate;\n      }\n    }\n    return new Date(doc); // Use r.ISO8601 and not `new Date()` to keep timezone\n  }\n  else if (type.isPoint(schema)) {\n    if (util.isPlainObject(doc) && (doc['$reql_type$'] !== \"GEOMETRY\")) {\n      var keys = Object.keys(doc).sort();\n      if ((keys.length === 2) && (keys[0] === 'latitude') && (keys[1] === 'longitude') && (typeof doc.latitude === \"number\") && (typeof doc.longitude === \"number\")) {\n        return r.point(doc.longitude, doc.latitude)\n      }\n      else if ((doc.type === \"Point\") && (Array.isArray(doc.coordinates)) && (doc.coordinates.length === 2)) { // Geojson\n        return r.geojson(doc)\n      }\n    }\n    else if (Array.isArray(doc)) {\n      if ((doc.length === 2) && (typeof doc[0] === \"number\") && (typeof doc[1] === \"number\")) {\n        return r.point(doc[0], doc[1])\n      }\n    }\n    else { // no transformation are required here, return doc\n      return doc;\n    }\n  }\n  else if (type.isNumber(schema) && (typeof doc === 'string')) {\n    var numericString = parseFloat(doc);\n    if(!isNaN(numericString)){\n      return numericString;\n    }else{\n      return doc;\n    }\n  }\n\n  if (util.isPlainObject(doc) && (doc instanceof Buffer === false)) {\n    result = {};\n    util.loopKeys(doc, function(doc, key) {\n      copyFlag = true;\n      if ((util.isPlainObject(model) === false) || (model._joins[key] === undefined)) { // We do not copy joined documents\n        if ((schema !== undefined) && (schema._schema !== undefined) && (type.isVirtual(schema._schema[key]) === true)) {\n          // We do not copy virtual\n        }\n        else if (((schema === undefined) || (schema._schema === undefined) || (schema._schema[key] === undefined)) &&\n            (localOptions !== undefined) && (localOptions.enforce_extra === \"remove\")) {\n          // We do not copy fields if enfroce_extra is \"remove\"\n        }\n        else {\n          if ((schema !== undefined) && (schema._schema !== undefined)) {\n            nextSchema = schema._schema[key];\n          }\n          else {\n            nextSchema = undefined;\n          }\n          result[key] = Document.prototype.__makeSavableCopy(doc[key], nextSchema, localOptions, undefined, r);\n        }\n      }\n    });\n\n    // Copy the fields that are used as foreign keys\n    if (util.isPlainObject(model) === true) {\n      util.loopKeys(model._localKeys, function(localKeys, localKey) {\n        if (doc[localKey] !== undefined) {\n          if (schema !== undefined) {\n            nextSchema = schema._schema[key];\n          }\n          else {\n            nextSchema = undefined;\n          }\n          //TODO: Do we want to copy the foreign key value? If yes, there's no need for this loop\n          //Do we want to copy the key from the joined document? If yes we need to replace doc[localKey]\n          result[localKey] = Document.prototype.__makeSavableCopy(doc[localKey], nextSchema, localOptions, undefined, r);\n        }\n      });\n    }\n    return result;\n  }\n  else if (Array.isArray(doc)) {\n    result = [];\n    copyFlag = true;\n\n    // Next schema\n    if (type.isArray(schema)) {\n      nextSchema = schema._schema;\n    }\n    else if ((util.isPlainObject(schema)) && (schema._type !== undefined) && (schema._schema !== undefined)) {\n      nextSchema = schema._schema\n      if (schema._type === \"virtual\") {\n        copyFlag = false;\n      }\n    }\n    else {\n      nextSchema = undefined;\n    }\n    if (copyFlag === true) {\n      for(var i=0; i<doc.length; i++) {\n        result.push(Document.prototype.__makeSavableCopy(doc[i], nextSchema, localOptions, undefined, r));\n      }\n    }\n    return result;\n  }\n  // else, doc is a primitive (or a buffer)\n  return doc;\n}\n\n\n/**\n * Save the document, its joined documents and execute the hooks. Return a\n * promise if the callback is undefined.\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Object=} savedModel Models saved in this call\n * @param {Object=} callback to execute\n * @return {Promise=}\n */\nDocument.prototype._save = function(docToSave, saveAll, savedModel, callback) {\n  //TOIMPROVE? How should we handle circular references outsides of joined fields? Now we throw with a maximum call stack size exceed\n  var self = this;\n  self.emit('saving', self);\n\n  return util.hook({\n    preHooks: self._getModel()._pre.save,\n    postHooks: self._getModel()._post.save,\n    doc: self,\n    async: true,\n    fn: self._saveHook,\n    fnArgs: [docToSave, saveAll, savedModel]\n  }).nodeify(callback);\n}\n\n\n/**\n * Save the document and execute the hooks. This is an internal method used with\n * Model.save. This let us use a similar code path for `document.save` and `Model.save`.\n * @param {Function} executeInsert the method that will execute the batch insert\n * @return {Promise}\n */\nDocument.prototype._batchSave = function(executeInsert) {\n  // Keep in sync with _save\n  var self = this;\n  self.emit('saving', self);\n\n  return util.hook({\n    preHooks: self._getModel()._pre.save,\n    postHooks: self._getModel()._post.save,\n    doc: self,\n    async: true,\n    fn: self._batchSaveSelf,\n    fnArgs: [executeInsert]\n  });\n}\n\n\n/**\n * Call executeInsert when the model is ready\n * @param {Function} executeInsert the method that will execute the batch insert\n * @return {Promise}\n */\nDocument.prototype._batchSaveSelf = function(executeInsert) {\n  var self = this;\n\n  return new Promise(function(resolve, reject) {\n    self.getModel().ready().then(function() {\n      executeInsert(resolve, reject)\n    });\n  })\n}\n\n\n/**\n * Save the document and maybe its joined documents. Hooks have been dealt with\n * in _save.\n * @param {!Object} copy The savable copy of the original documents.\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {Object=} belongsToKeysSaved The keys that may contains a document to save\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Object=} savedModel Models saved in this call\n * @param {Function} resolve The function to call when everything has been saved\n * @param {Function} reject The function to call if an error happened\n */\nDocument.prototype._saveHook = function(docToSave, saveAll, savedModel) {\n  var self = this;\n  var model = self._getModel(); // instance of Model\n  var constructor = self.getModel();\n  var r = model._thinky.r;\n\n  if (util.isPlainObject(docToSave) === false) {\n    docToSave = {};\n  }\n\n  savedModel[constructor.getTableName()] = true;\n\n\n  var p = new Promise(function(resolve, reject) {\n    // Steps:\n    // - Save belongsTo\n    // - Save this\n    // - Save hasOne, hasMany and hasAndBelongsToMany docs\n    // - Save links\n\n    // We'll use it to know which `belongsTo` docs were saved\n    var belongsToKeysSaved = {};\n\n    var copy = self._makeSavableCopy();\n    self._saveVirtual();\n\n    // Save the joined documents via belongsTo first\n    var promises = [];\n    util.loopKeys(model._joins, function(joins, key) {\n      if ((docToSave.hasOwnProperty(key) || (saveAll === true)) &&\n          (joins[key].type === 'belongsTo') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))) {\n\n        belongsToKeysSaved[key] = true;\n        if (self[key] != null) {\n          savedModel[joins[key].model.getTableName()] = true;\n          if (saveAll === true) {\n            promises.push(self[key]._save({}, true, savedModel))\n          }\n          else {\n            promises.push(self[key]._save(docToSave[joins[key].model.getTableName()], false, savedModel))\n          }\n        }\n      }\n    });\n\n    //TODO Remove once\n    self.getModel().ready().then(function() {\n      Promise.all(promises).then(function() {\n        self._onSavedBelongsTo(copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject);\n      }).error(reject);\n    });\n  });\n  return p;\n}\n\n\n/**\n * Save the joined documents linked with a BelongsTo relation. This should be\n * called before _saveSelf as we will have to copy the foreign keys in `self`.\n * @param {!Object} copy The savable copy of the original documents.\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {Object=} belongsToKeysSaved The keys that may contains a document to save\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Object=} savedModel Models saved in this call\n * @param {Function} resolve The function to call when everything has been saved\n * @param {Function} reject The function to call if an error happened\n */\nDocument.prototype._onSavedBelongsTo = function(\n    copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject) {\n  var self = this;\n  var model = self._getModel();\n  var constructor = self.__proto__.constructor;\n  var r = this._getModel()._thinky.r;\n\n  util.loopKeys(belongsToKeysSaved, function(joins, key) {\n    var joins = model._joins;\n    if (self[key] != null) {\n\n      self.__proto__._belongsTo[key] = true;\n\n      // Copy foreign key\n      if (self[key][joins[key].rightKey] == null) {\n        if (self.hasOwnProperty(joins[key].leftKey)) {\n          delete self[joins[key][joins[key].leftKey]];\n        }\n        if (copy.hasOwnProperty(joins[key].leftKey)) {\n          delete copy[joins[key][joins[key].leftKey]];\n        }\n      }\n      else {\n        self[joins[key].leftKey] = self[key][joins[key].rightKey];\n        copy[joins[key].leftKey] = self[key][joins[key].rightKey]; // We need to put it in copy before saving it\n      }\n\n      // Save the document that belongs to self[key]\n      if (self[key].__proto__._parents._belongsTo[constructor.getTableName()] == null) {\n        self[key].__proto__._parents._belongsTo[constructor.getTableName()] = [];\n      }\n      self[key].__proto__._parents._belongsTo[constructor.getTableName()].push({\n        doc: self,\n        foreignKey: joins[key].leftKey,\n        key: key // foreignDoc\n      });\n    }\n  });\n  self._saveSelf(copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject)\n}\n\n\n/**\n * Save the document on which `save` was called.\n * @param {!Object} copy The savable copy of the original documents.\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {Object=} belongsToKeysSaved The keys that may contains a document to save\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Object=} savedModel Models saved in this call\n * @param {Function} resolve The function to call when everything has been saved\n * @param {Function} reject The function to call if an error happened\n */\nDocument.prototype._saveSelf = function(\n    copy, docToSave, belongsToKeysSaved, saveAll, savedModel, resolve, reject) {\n  var self = this;\n  var model = self._getModel();\n  var constructor = self.__proto__.constructor;\n  var r = this._getModel()._thinky.r;\n\n  // BelongsTo documents were saved before. We just need to copy the foreign\n  // keys.\n  util.loopKeys(model._joins, function(joins, key) {\n    if ((joins[key].type === 'belongsTo') && (belongsToKeysSaved[key] === true)) {\n      if (self[key] != null) {\n        self[joins[key].leftKey] = self[key][joins[key].rightKey]\n      }\n      else if (self.__proto__._belongsTo[key]) {\n        delete self[joins[key].leftKey];\n        delete copy[joins[key].leftKey];\n      }\n    }\n  });\n\n  var querySaveSelf; // The query to save the document on which `save`/`saveAll` was called.\n  // We haven't validated the document yet, so building the query with `copy`\n  // may throw an error (for example if a Date has not a valid time).\n  var buildQuery = function () {\n    if (self.__proto__._saved === false) {\n      return querySaveSelf = r.table(constructor.getTableName())\n        .insert(copy, {returnChanges: 'always'})\n    }\n    else {\n      if (copy[model._pk] === undefined) {\n        throw new Error(\"The document was previously saved, but its primary key is undefined.\");\n      }\n      return querySaveSelf = r.table(constructor.getTableName())\n        .get(copy[model._pk]).replace(copy, {returnChanges: 'always'})\n    }\n  }\n\n  self.getModel().ready().then(function() {\n    util.tryCatch(function() {\n      // Validate the document before saving it\n      var promise = self.validate();\n      if (promise instanceof Promise) {\n        promise.then(function() {\n          querySaveSelf = buildQuery();\n          querySaveSelf.run().then(function(result) {\n            self._onSaved(result, docToSave, saveAll, savedModel, resolve, reject)\n          }).error(reject)\n        }).error(reject);\n      }\n      else {\n        querySaveSelf = buildQuery();\n        querySaveSelf.run().then(function(result) {\n          self._onSaved(result, docToSave, saveAll, savedModel, resolve, reject)\n        }).error(reject)\n      }\n    }, reject);\n  });\n}\n\n\n/**\n * Callback for the insert query.\n * @param {Object} result The result from the insert query\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Object=} savedModel Models saved in this call\n * @param {Function} resolve The function to call when everything has been saved\n * @param {Function} reject The function to call if an error happened\n */\nDocument.prototype._onSaved = function(result, docToSave, saveAll, savedModel, resolve, reject) {\n  // Keep in sync with Model.save\n  var self = this;\n\n  if (result.first_error != null) {\n    return reject(Errors.create(result.first_error));\n  }\n\n  util.tryCatch(function() { // Validate the doc, replace it, and tag it as saved\n    if (Array.isArray(result.changes) && result.changes.length > 0) {\n      self._merge(result.changes[0].new_val);\n      self._setOldValue(util.deepCopy(result.changes[0].old_val));\n    }\n\n    if (self._getModel().needToGenerateFields === true) {\n      self._generateDefault();\n    }\n    self.setSaved();\n    self.emit('saved', self);\n\n    var promise = self.validate();\n    if (promise instanceof Promise) {\n      promise.then(function() {\n        self._saveMany(docToSave, saveAll, savedModel, resolve, reject)\n      }).error(reject);\n    }\n    else {\n      self._saveMany(docToSave, saveAll, savedModel, resolve, reject)\n    }\n  }, reject);\n}\n\n\n/**\n * Save the joined documents linked with a hasOne or hasMany or\n * hasAndBelongsToMany relation. This should be called after `_saveSelf` as we\n * will have to copy the foreign keys in the joined documents.\n * @param {Object} result The result from the insert query\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Object=} savedModel Models saved in this call\n * @param {Function} resolve The function to call when everything has been saved\n * @param {Function} reject The function to call if an error happened\n */\nDocument.prototype._saveMany = function(docToSave, saveAll, savedModel, resolve, reject) {\n  var self = this;\n  var model = self._getModel();\n\n  var promisesMany = [];\n  util.loopKeys(model._joins, function(joins, key) {\n    if (((key in docToSave) || (saveAll === true)) &&\n        (joins[key].type === 'hasOne') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))) {\n      savedModel[joins[key].model.getTableName()] = true;\n\n      if (self[key] != null) {\n        self[key][joins[key].rightKey] = self[joins[key].leftKey];\n        (function(_key) {\n          promisesMany.push(new Promise(function(resolve, reject) {\n            self[_key]._save(docToSave[_key], saveAll, savedModel).then(function() {\n              self.__proto__._hasOne[_key] = {\n                doc: self[_key],\n                foreignKey: self._getModel()._joins[_key].rightKey\n              };\n              if (self[_key].__proto__._parents._hasOne[self._getModel()._name] == null) {\n                self[_key].__proto__._parents._hasOne[self._getModel()._name] = [];\n              }\n              self[_key].__proto__._parents._hasOne[self._getModel()._name].push({\n                doc: self,\n                key: key\n              });\n              resolve();\n            }).error(reject);\n          }))\n        })(key)\n      }\n      else if ((self[key] == null) && (self.__proto__._hasOne[key] != null)) {\n        var doc = self.__proto__._hasOne[key].doc;\n        delete doc[self.__proto__._hasOne[key].foreignKey];\n        promisesMany.push(doc._save(docToSave[key], saveAll, savedModel))\n        self.__proto__._hasOne[key] = null;\n      }\n    }\n  });\n  util.loopKeys(model._joins, function(joins, key) {\n    if (((key in docToSave) || (saveAll === true)) &&\n        (joins[key].type === 'hasMany') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))\n        && (Array.isArray(self[key]))) {\n\n      savedModel[joins[key].model.getTableName()] = true;\n\n      //Go through _hasMany and find element that were removed\n      var pkMap = {};\n      if (Array.isArray(self[key])) {\n        for(var i=0; i<self[key].length; i++) {\n          if (self[key][i][joins[key].model._pk] != null) {\n            pkMap[self[key][i][joins[key].model._pk]] = true;\n          }\n        }\n      }\n\n      if (self.__proto__._hasMany[key] != null) {\n        for(var i=0; i<self.__proto__._hasMany[key].length; i++) {\n          if (pkMap[self.__proto__._hasMany[key][i].doc[[joins[key].model._pk]]] == null) {\n            delete self.__proto__._hasMany[key][i].doc[self.__proto__._hasMany[key][i].foreignKey];\n            promisesMany.push(self.__proto__._hasMany[key][i].doc._save(docToSave[key], saveAll, savedModel));\n          }\n        }\n      }\n      self.__proto__._hasMany[key] = [];\n\n      for(var i=0; i<self[key].length; i++) {\n        self[key][i][joins[key].rightKey] = self[joins[key].leftKey];\n        (function(key, i) {\n          promisesMany.push(new Promise(function(resolve, reject) {\n            if (!(self[key][i] instanceof Document)) {\n              self[key][i] = new joins[key].model(self[key][i]);\n            }\n\n            var callback = function() {\n              self[key][i]._save(docToSave[key], saveAll, savedModel).then(function(doc) {\n                if (!Array.isArray(self.__proto__._hasMany[key])) {\n                  self.__proto__._hasMany[key] = [];\n                }\n                self.__proto__._hasMany[key].push({\n                  doc: doc,\n                  foreignKey: self._getModel()._joins[key].rightKey\n                });\n\n                if (self[key][i].__proto__._parents._hasMany[self._getModel()._name] == null) {\n                  self[key][i].__proto__._parents._hasMany[self._getModel()._name] = [];\n                }\n                self[key][i].__proto__._parents._hasMany[self._getModel()._name].push({\n                  doc: self,\n                  key: key\n                });\n\n                resolve();\n              }).error(reject);\n            }\n\n            if (self[key][i] instanceof Promise) {\n              self[key][i].then(callback).error(reject);\n            }\n            else {\n              callback();\n            }\n\n          }))\n        })(key, i);\n      }\n    }\n  });\n  util.loopKeys(model._joins, function(joins, key) {\n    // Compare to null\n    if (((key in docToSave) || (saveAll === true)) &&\n        (joins[key].type === 'hasAndBelongsToMany') && ((saveAll === false) || (savedModel[joins[key].model.getTableName()] !== true))) {\n\n      savedModel[joins[key].model.getTableName()] = true;\n\n      if (Array.isArray(self[key])) {\n        for(var i=0; i<self[key].length; i++) {\n          if (util.isPlainObject(self[key][i])) { // Save only if we have a full object, and not just a key\n            (function(key, i) {\n              promisesMany.push(new Promise(function(resolve, reject) {\n                if (!(self[key][i] instanceof Document)) {\n                  self[key][i] = new joins[key].model(self[key][i]);\n                }\n                var callback = function() {\n                  self[key][i]._save(docToSave[key], saveAll, savedModel).then(function() {\n                    // self.__proto__._links will be saved in saveLinks\n                    if (self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] == null) {\n                      self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] = [];\n                    }\n                    self[key][i].__proto__._parents._belongsLinks[self._getModel()._name].push({\n                      doc: self,\n                      key: key\n                    });\n                    resolve();\n                  }).error(reject);\n                }\n\n                if (self[key][i] instanceof Promise) {\n                  self[key][i].then(callback).error(reject);\n                }\n                else {\n                  callback();\n                }\n              }))\n            })(key, i)\n          }\n        }\n      }\n    }\n  });\n\n  if (promisesMany.length > 0) {\n    Promise.all(promisesMany).then(function() {\n      self._saveLinks(docToSave, saveAll, resolve, reject)\n    }).error(reject);\n  }\n  else {\n    self._saveLinks(docToSave, saveAll, resolve, reject)\n  }\n}\n\n\n/**\n * Save the links for hasAndBelongsToMany joined documents.\n * called before _saveSelf as we will have to copy the foreign keys in `self`.\n * @param {Object=} docToSave Documents to save represented by an object field->true\n * @param {boolean} saveAll Whether _save should recurse by default or not\n * @param {Function} resolve The function to call when everything has been saved\n * @param {Function} reject The function to call if an error happened\n */\nDocument.prototype._saveLinks = function(docToSave, saveAll, resolve, reject) {\n  var self = this;\n  var model = self._getModel();\n  var constructor = self.getModel();\n  var r = model._thinky.r;\n\n  var promisesLink = [];\n\n  util.loopKeys(model._joins, function(joins, key) {\n    // Write tests about that!\n    if (((key in docToSave) || (saveAll === true)) &&\n        (joins[key].type === 'hasAndBelongsToMany')) {\n\n      if (Array.isArray(self[key])) {\n        var newKeys = {}\n        for(var i=0; i<self[key].length; i++) {\n          if (util.isPlainObject(self[key][i])) {\n            if (self[key][i].isSaved() === true) {\n              newKeys[self[key][i][joins[key].rightKey]] = true;\n            }\n          }\n          else { // self[key][i] is just the key\n            newKeys[self[key][i]] = true;\n          }\n        }\n\n        if (self.__proto__._links[joins[key].link] === undefined) {\n          self.__proto__._links[joins[key].link] = {}\n        }\n        var oldKeys = self.__proto__._links[joins[key].link];\n\n        util.loopKeys(newKeys, function(newKeys, link) {\n          if (oldKeys[link] !== true) {\n            var newLink = {};\n\n            if ((constructor.getTableName() === joins[key].model.getTableName())\n              && (joins[key].leftKey === joins[key].rightKey)) {\n\n              // We link on the same model and same key\n              // We don't want to save redundant field\n              if (link < self[joins[key].leftKey]) {\n                newLink.id = link+\"_\"+self[joins[key].leftKey];\n              }\n              else {\n                newLink.id = self[joins[key].leftKey]+\"_\"+link;\n              }\n              newLink[joins[key].leftKey+\"_\"+joins[key].leftKey] = [link, self[joins[key].leftKey]];\n            }\n            else {\n              newLink[constructor.getTableName()+\"_\"+joins[key].leftKey] = self[joins[key].leftKey];\n              newLink[joins[key].model.getTableName()+\"_\"+joins[key].rightKey] = link;\n\n              // Create the primary key\n              if (constructor.getTableName() < joins[key].model.getTableName()) {\n                newLink.id = self[joins[key].leftKey]+\"_\"+link;\n              }\n              else if (constructor.getTableName() > joins[key].model.getTableName()) {\n                newLink.id = link+\"_\"+self[joins[key].leftKey];\n              }\n              else {\n                if (link < self[joins[key].leftKey]) {\n                  newLink.id = link+\"_\"+self[joins[key].leftKey];\n                }\n                else {\n                  newLink.id = self[joins[key].leftKey]+\"_\"+link;\n                }\n              }\n            }\n\n            (function(key, link) {\n              promisesLink.push(new Promise(function(resolve, reject) {\n                r.table(self._getModel()._joins[key].link).insert(newLink, {conflict: \"replace\", returnChanges: 'always'}).run().then(function(result) {\n                  if (Array.isArray(result.changes) && result.changes.length > 0) {\n                    self.__proto__._links[joins[key].link][result.changes[0].new_val[joins[key].model.getTableName()+\"_\"+joins[key].rightKey]] = true;\n                  }\n                  else {\n                    self.__proto__._links[joins[key].link][newLink[joins[key].model.getTableName()+\"_\"+joins[key].rightKey]] = true;\n                  }\n                  resolve();\n                }).error(reject);\n              }))\n            })(key, link);\n          }\n        });\n\n        var keysToDelete = []\n        util.loopKeys(oldKeys, function(oldKeys, link) {\n          if (newKeys[link] === undefined) {\n            if (constructor.getTableName() < joins[key].model.getTableName()) {\n              keysToDelete.push(self[joins[key].leftKey]+\"_\"+link);\n            }\n            else {\n              keysToDelete.push(link+\"_\"+self[joins[key].leftKey]);\n            }\n          }\n        });\n        if (keysToDelete.length > 0) {\n          var table = r.table(joins[key].link);\n          promisesLink.push(table.getAll.apply(table, keysToDelete).delete().run().then(function() {\n            for(var i=0; i<keysToDelete.length; i++) {\n              self.__proto__._links[joins[key].link][keysToDelete[i]] = false;\n            }\n          }));\n        }\n      }\n    }\n  });\n\n  if (promisesLink.length > 0) {\n    Promise.all(promisesLink).then(function() {\n      resolve(self);\n    }).error(reject);\n  }\n  else {\n    resolve(self);\n  }\n}\n\n\n/**\n * Return the value saved in __proto__.oldValue\n */\nDocument.prototype.getOldValue = function() {\n  return this.__proto__.oldValue;\n}\n\n\n/**\n * Save a reference of `value` that will be later accessible with `getOldValue`.\n * @param {Object} value The value to save\n */\nDocument.prototype._setOldValue = function(value) {\n  return this.__proto__.oldValue = value;\n}\n\n\n/**\n * Return whether this document was saved or not.\n * @return {boolean}\n */\nDocument.prototype.isSaved = function() {\n  return this.__proto__._saved;\n}\n\n\n/**\n * Set the document (and maybe its joined documents) as saved.\n * @param {boolean=} all Recursively set all the joined documents as saved\n */\nDocument.prototype.setSaved = function(all) {\n  var self = this;\n  self.__proto__._saved = true;\n  if (all !== true) return;\n    util.loopKeys(self._getModel()._joins, function(joins, key) {\n      switch (joins[key].type) {\n        case 'hasOne':\n          if (self[key] instanceof Document) {\n            self[key].setSaved(true);\n          }\n          break;\n\n        case 'belongsTo':\n          if (self[key] instanceof Document) {\n            self[key].setSaved(true);\n          }\n          break;\n\n        case 'hasMany':\n          if (Array.isArray(self[key])) {\n            for(var i=0; i<self[key].length; i++) {\n              if (self[key][i] instanceof Document) {\n                self[key][i].setSaved(true);\n              }\n            }\n          }\n          break;\n\n        case 'hasAndBelongsToMany':\n          if (Array.isArray(self[key])) {\n            for(var i=0; i<self[key].length; i++) {\n              if (self[key][i] instanceof Document) {\n                self[key][i].setSaved(true);\n              }\n            }\n          }\n          break;\n      }\n    });\n\n    // Make joins, we should keep references only of the saved documents\n    util.loopKeys(self._getModel()._joins, function(joins, key) {\n      if (self[key] == null) return;\n      switch (joins[key].type) {\n        case 'hasOne':\n          if (self[key].isSaved()) {\n            self.__proto__._hasOne[key] = {\n              doc: self[key],\n              foreignKey: self._getModel()._joins[key].rightKey\n            }\n          }\n\n          if (self[key].__proto__._parents._hasOne[self._getModel()._name] == null) {\n            self[key].__proto__._parents._hasOne[self._getModel()._name] = [];\n          }\n          self[key].__proto__._parents._hasOne[self._getModel()._name].push({\n            doc: self,\n            key: key\n          });\n          break;\n\n        case 'belongsTo':\n          if (self[key].__proto__._parents._belongsTo[self._getModel()._name] == null) {\n            self[key].__proto__._parents._belongsTo[self._getModel()._name] = [];\n          }\n          self[key].__proto__._parents._belongsTo[self._getModel()._name].push({\n            doc: self,\n            foreignKey: self._getModel()._joins[key].leftKey,\n            key: key\n          });\n          self.__proto__._belongsTo[key] = true;\n          break;\n\n        case 'hasMany':\n          self.__proto__._hasMany[key] = []\n\n          for(var i=0; i<self[key].length; i++) {\n            if (self[key][i].isSaved()) {\n              self.__proto__._hasMany[key].push({\n                doc: self[key][i],\n                foreignKey: self._getModel()._joins[key].rightKey\n              })\n            }\n\n            if (self[key][i].__proto__._parents._hasMany[self._getModel()._name] == null) {\n              self[key][i].__proto__._parents._hasMany[self._getModel()._name] = [];\n            }\n            self[key][i].__proto__._parents._hasMany[self._getModel()._name].push({\n              doc: self,\n              key: key\n            });\n\n          }\n          break;\n\n        case 'hasAndBelongsToMany':\n          if (self.__proto__._links[self._getModel()._joins[key].link] === undefined) {\n            self.__proto__._links[self._getModel()._joins[key].link] = {}\n          }\n\n          for(var i=0; i<self[key].length; i++) {\n            if (self[key][i].isSaved()) {\n              self.__proto__._links[self._getModel()._joins[key].link][self[key][i][self._getModel()._joins[key].rightKey]] = true;\n            }\n\n            if (self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] == null) {\n              self[key][i].__proto__._parents._belongsLinks[self._getModel()._name] = [];\n            }\n            self[key][i].__proto__._parents._belongsLinks[self._getModel()._name].push({\n              doc: self,\n              key: key\n            });\n\n          }\n          break;\n      }\n    });\n\n}\n\n\n/**\n * Set the document as unsaved\n */\nDocument.prototype._setUnSaved = function() {\n  this.__proto__._saved = false;\n}\n\n\n/**\n * Delete the document from the database. Update the joined documents by\n * removing the foreign key for hasOne/hasMany joined documents, and remove the\n * links for hasAndBelongsToMany joined documents if the link is built on the\n * primary key.\n * @param {Function=} callback\n * @return {Promise=} Return a promise if no callback is provided\n */\nDocument.prototype.delete = function(callback) {\n  return this._delete({}, false, [], true, true, callback)\n}\n\n\n/**\n * Delete the document from the database and the joined documents. If\n * `docToDelete` is undefined, it will delete all the joined documents, else it\n * will limits itself to the one stored in the keys defined in `docToDelete`.\n * It will also update the joined documents by removing the foreign key for\n * `hasOne`/`hasMany` joined documents, and remove the links for\n * `hasAndBelongsToMany` joined documents if the link is built on the primary\n * key.\n * @param {Object=} docToDelete An object where a field maps to `true` if the\n * document stored in this field should be deleted.\n * @param {Function=} callback\n * @return {Promise=} Return a promise if no callback is provided\n */\nDocument.prototype.deleteAll = function(docToDelete, callback) {\n  var deleteAll;\n  if (typeof docToDelete === 'function') {\n    callback = docToDelete;\n    deleteAll = true;\n    docToDelete = {};\n  }\n  else {\n    deleteAll = docToDelete === undefined;\n    docToDelete = docToDelete || {};\n  }\n  return this._delete(docToDelete, deleteAll, [], true, true, callback)\n}\n\n\n/**\n * Delete the document from the database and the joined documents. If\n * `docToDelete` is `undefined` and `deleteAll` is `true`, it will delete all\n * the joined documents, else it will limits itself to the one stored in the\n * keys defined in `docToDelete`. It will also update the joined documents by\n * removing the foreign key for `hasOne`/`hasMany` joined documents, and\n * remove the links for `hasAndBelongsToMany` joined documents if the link is\n * built on the primary key.\n * Hooks will also be executed.\n * @param {Object=} docToDelete Explicit maps of the documents to delete\n * @param {boolean} deleteAll Recursively delete all the documents if\n *     `docToDelete` is undefined\n * @param {Array} deletedDocs Array of docs already deleted, used to make sure\n *     that we do not try to delete multiple times the same documents\n * @param {boolean} deleteSelf Whether it should delete self\n * @param {boolean} updateParents Whether it should update the keys for the\n *     parents\n * @param {Function=} callback\n * @return {Promise=} Return a promise if no callback is provided\n */\nDocument.prototype._delete = function(docToDelete, deleteAll, deletedDocs, deleteSelf, updateParents, callback) {\n  //TODO Set a (string) id per document and use it to perform faster lookup\n  var self = this;\n\n  if (util.isPlainObject(docToDelete) === false) {\n    docToDelete = {};\n  }\n\n  deleteSelf = (deleteSelf === undefined) ? true: deleteSelf;\n\n  return util.hook({\n    preHooks: self._getModel()._pre.delete,\n    postHooks: self._getModel()._post.delete,\n    doc: self,\n    async: true,\n    fn: self._deleteHook,\n    fnArgs: [docToDelete, deleteAll, deletedDocs, deleteSelf, updateParents, callback]\n  });\n}\n\n\n/**\n * Internal methods used in `_delete`. Does the same as `_delete` but without\n * the hooks.\n * @param {Object=} docToDelete Explicit maps of the documents to delete\n * @param {boolean} deleteAll Recursively delete all the documents if\n *     `docToDelete` is undefined\n * @param {Array} deletedDocs Array of docs already deleted, used to make sure\n *     that we do not try to delete multiple times the same documents\n * @param {boolean} deleteSelf Whether it should delete self\n * @param {boolean} updateParents Whether it should update the keys for the\n *     parents\n * @return {Promise=} Return a promise if no callback is provided\n */\nDocument.prototype._deleteHook = function(docToDelete, deleteAll, deletedDocs, deleteSelf, updateParents, callback) {\n  var self = this;\n  var model = self._getModel(); // instance of Model\n  var constructor = self.getModel();\n  var r = model._thinky.r;\n\n  var promises = [];\n\n  deletedDocs.push(self);\n  util.loopKeys(self._getModel()._joins, function(joins, key) {\n    if ((joins[key].type === 'hasOne') && (self[key] instanceof Document)) {\n      if ((self[key].isSaved() === true) &&\n        ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key]) === -1)))) {\n\n        (function(key) {\n          promises.push(new Promise(function(resolve, reject) {\n            self[key]._delete(docToDelete[key], deleteAll, deletedDocs, true, false).then(function() {\n              delete self[key];\n              resolve();\n            }).error(reject);\n          }))\n        })(key);\n      }\n      else if ((deleteSelf === true) && (deletedDocs.indexOf(self[key]) === -1)) {\n        delete self[key][joins[key].rightKey];\n        if (self[key].isSaved() === true) {\n          promises.push(self[key].save({}, false, {}, true, false));\n        }\n      }\n    }\n    if ((joins[key].type === 'belongsTo') && (self[key] instanceof Document)) {\n      if ((self[key].isSaved() === true) &&\n        ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key]) === -1)))) {\n\n        (function(key) {\n          promises.push(new Promise(function(resolve, reject) {\n            self[key]._delete(docToDelete[key], deleteAll, deletedDocs, true, false).then(function() {\n              delete self[key];\n              resolve();\n            }).error(reject);\n          }));\n        })(key);\n      }\n    }\n\n    if ((joins[key].type === 'hasMany') && (Array.isArray(self[key]))) {\n      var manyPromises = [];\n      for(var i=0; i<self[key].length; i++) {\n        if (((self[key][i] instanceof Document) && (self[key][i].isSaved() === true))\n          && ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key][i]) === -1)))) {\n\n          manyPromises.push(self[key][i]._delete(docToDelete[key], deleteAll, deletedDocs, true, false))\n        }\n        else if ((self[key][i] instanceof Document) && (deletedDocs.indexOf(self[key][i]) === -1)) {\n          delete self[key][i][joins[key].rightKey];\n          if (self[key][i].isSaved() === true) {\n            promises.push(self[key][i].save({}, false, {}, true, false))\n          }\n        }\n      }\n      (function(key) {\n        promises.push(new Promise(function(resolve, reject) {\n          Promise.all(manyPromises).then(function() {\n            delete self[key];\n            resolve()\n          })\n        }));\n      })(key)\n    }\n    if ((joins[key].type === 'hasAndBelongsToMany') && (Array.isArray(self[key]))) {\n      // Delete links + docs\n      var pks = []; // primary keys of the documents\n      var linksPks = []; // primary keys of the links\n\n      // Store the element we are going to delete.\n      // If the user force the deletion of the same element multiple times, we can't naively loop\n      // over the elements in the array...\n      var docsToDelete = [];\n\n\n      for(var i=0; i<self[key].length; i++) {\n        if (((self[key][i] instanceof Document) && (self[key][i].isSaved() === true))\n          && ((key in docToDelete) || ((deleteAll === true) && (deletedDocs.indexOf(self[key][i]) === -1)))) {\n\n          //pks.push(self[key][i][joins[key].model._getModel()._pk]);\n          docsToDelete.push(self[key][i]);\n          // We are going to do a range delete, but we still have to recurse\n          promises.push(self[key][i]._delete(docToDelete[key], deleteAll, deletedDocs, true, false))\n\n          if (self.getModel()._getModel()._pk === joins[key].leftKey) {\n            // The table is created since we are deleting an element from it\n            if (self._getModel()._name === joins[key].model._getModel()._name) {\n              if (self[joins[key].leftKey] < self[key][i][joins[key].rightKey]) {\n                //TODO Add test for this\n                linksPks.push(self[joins[key].leftKey]+\"_\"+self[key][i][joins[key].rightKey]);\n              }\n              else {\n                linksPks.push(self[key][i][joins[key].rightKey]+\"_\"+self[joins[key].leftKey]);\n              }\n            }\n            else if (self._getModel()._name < joins[key].model._getModel()._name) {\n              linksPks.push(self[joins[key].leftKey]+\"_\"+self[key][i][joins[key].rightKey]);\n            }\n            else {\n              linksPks.push(self[key][i][joins[key].rightKey]+\"_\"+self[joins[key].leftKey]);\n            }\n          }\n        }\n        else if ((self[key][i] instanceof Document) && (deletedDocs.indexOf(self[key][i]) === -1)) {\n          // It's safe to destroy links only if it's a primary key\n          if (self.getModel()._getModel()._pk === joins[key].leftKey) {\n            if (self._getModel()._name < joins[key].model._getModel()._name) {\n              linksPks.push(self[joins[key].leftKey]+\"_\"+self[key][i][joins[key].rightKey]);\n            }\n            else {\n              linksPks.push(self[key][i][joins[key].rightKey]+\"_\"+self[joins[key].leftKey]);\n            }\n          }\n        }\n      }\n      if (linksPks.length > 0) {\n        var query = r.table(joins[key].link);\n        query = query.getAll.apply(query, linksPks).delete();\n        promises.push(query.run());\n      }\n    }\n  });\n  if (updateParents !== false) {\n    // Clean links that we are aware of\n    util.loopKeys(self.__proto__._parents._hasOne, function(hasOne, key) {\n      var parents = hasOne[key];\n      for(var i=0; i<parents.length; i++) {\n        delete parents[i].doc[parents[i].key];\n        util.loopKeys(parents[i].doc.__proto__._hasOne, function(joined, joinKey) {\n          if (joined[joinKey].doc === self) {\n            delete parents[i].doc.__proto__._hasOne[joinKey];\n          }\n        })\n      }\n    });\n    util.loopKeys(self.__proto__._parents._belongsTo, function(belongsTo, key) {\n      var parents = belongsTo[key];\n      for(var i=0; i<parents.length; i++) {\n        delete parents[i].doc[parents[i].key];\n        delete parents[i].doc[parents[i].foreignKey];\n        if (deletedDocs.indexOf(parents[i]) === -1) {\n          promises.push(parents[i].doc.save());\n        }\n      }\n    });\n    util.loopKeys(self.__proto__._parents._hasMany, function(hasMany, key) {\n      var parents = hasMany[key];\n      for(var i=0; i<parents.length; i++) {\n        for(var j=0; j<parents[i].doc[parents[i].key].length; j++) {\n          if (parents[i].doc[parents[i].key][j] === self) {\n            util.loopKeys(parents[i].doc.__proto__._hasMany, function(joined, joinKey) {\n              for(var k=0; k<joined[joinKey].length; k++) {\n                if (joined[joinKey][k].doc === self) {\n                  joined[joinKey].splice(k, 1);\n                  return false;\n                }\n              }\n            });\n            parents[i].doc[parents[i].key].splice(j, 1);\n            break;\n          }\n        }\n      }\n    });\n    util.loopKeys(self.__proto__._parents._belongsLinks, function(belongsLinks, key) {\n      var parents = belongsLinks[key];\n      for(var i=0; i<parents.length; i++) {\n        for(var j=0; j<parents[i].doc[parents[i].key].length; j++) {\n          if (parents[i].doc[parents[i].key][j] === self) {\n            parents[i].doc[parents[i].key].splice(j, 1);\n            break;\n          }\n        }\n      }\n    });\n  }\n\n  if (deleteSelf !== false) {\n    if (self.isSaved() === true) {\n      promises.push(new Promise(function(resolve, reject) {\n        r.table(model._name).get(self[model._pk]).delete().run().then(function(result) {\n          self._setUnSaved();\n          self.emit('deleted', self);\n          resolve(self);\n        }).error(reject);\n      }))\n    }\n    // else we don't throw an error, should we?\n  }\n\n  var p = new Promise(function(resolve, reject) {\n    Promise.all(promises).then(function(result) {\n      resolve(self);\n    }).error(function(error) {\n      reject(error)\n    });\n  })\n  return p.nodeify(callback);\n}\n\n/*\n * Delete this document and purge the database by doing range update to clean\n * the foreign keys.\n * @param {Function=} callback\n * @return {Promise=} Return a promise if no callback is provided\n */\nDocument.prototype.purge = function(callback) {\n  var self = this;\n\n  var model = self._getModel(); // instance of Model\n  var r = model._thinky.r;\n\n  // Clean parent for hasOne\n  // doc.otherDoc.delete()\n  util.loopKeys(self.__proto__._parents._hasOne, function(hasOne, key) {\n    for(var i=0; i<hasOne[key].length; i++) {\n      var parentDoc = hasOne[key][i].doc; // A doc that belongs to otherDoc (aka this)\n      delete parentDoc[hasOne[key][i].key] // Delete reference to otherDoc (aka this)\n    }\n  });\n\n  // Clean parent for belongsTo\n  // doc.otherDoc.delete()\n  util.loopKeys(self.__proto__._parents._belongsTo, function(belongsTo, key) {\n    for(var i=0; i<belongsTo[key].length; i++) {\n      var parentDoc = belongsTo[key][i].doc;\n      delete parentDoc[belongsTo[key][i].key];\n      delete parentDoc[belongsTo[key][i].foreignKey];\n    }\n  });\n\n  // Clean parent for hasMany\n  util.loopKeys(self.__proto__._parents._hasMany, function(hasMany, key) {\n    for(var i=0; i<hasMany[key].length; i++) {\n      var parentDoc = hasMany[key][i].doc;\n      var field = hasMany[key][i].key;\n      for(var j=0; j<parentDoc[field].length; j++) {\n        if (parentDoc[field][j] === this) {\n          parentDoc[field].splice(j, 1);\n          break;\n        }\n      }\n    }\n  });\n\n\n  // Clean parent for hasAndBelongsToMany\n  util.loopKeys(self.__proto__._parents._belongsLinks, function(belongsLinks, key) {\n    for(var i=0; i<belongsLinks[key].length; i++) {\n      var parentDoc = belongsLinks[key][i].doc;\n      var field = belongsLinks[key][i].key;\n      for(var j=0; j<parentDoc[field].length; j++) {\n        if (parentDoc[field][j] === this) {\n          parentDoc[field].splice(j, 1);\n          break;\n        }\n      }\n    }\n  });\n\n  // Purge the database\n  var promises = [];\n  util.loopKeys(self._getModel()._joins, function(joins, field) {\n    var join = joins[field];\n    var joinedModel = join.model;\n\n    if ((join.type === 'hasOne') || (join.type === 'hasMany')) {\n      promises.push(r.table(joinedModel.getTableName()).getAll(self[join.leftKey], {index: join.rightKey}).replace(function(doc) {\n        return doc.without(join.rightKey)\n      }).run())\n    }\n    // nothing to do for \"belongsTo\"\n    else if (join.type === 'hasAndBelongsToMany') {\n      if (self.getModel()._getModel()._pk === join.leftKey) {\n        // [1]\n        promises.push(r.table(join.link).getAll(self[join.leftKey], {index: self.getModel().getTableName()+\"_\"+join.leftKey}).delete().run())\n      }\n    }\n  });\n\n  util.loopKeys(self._getModel()._reverseJoins, function(reverseJoins, field) {\n    var join = reverseJoins[field];\n    var joinedModel = join.model; // model where belongsTo/hasAndBelongsToMany was called\n\n    if (join.type === 'belongsTo') {\n      // What was called is joinedModel.belongsTo(self, fieldDoc, leftKey, rightKey)\n      promises.push(r.table(joinedModel.getTableName()).getAll(self[join.rightKey], {index: join.leftKey}).replace(function(doc) {\n        return doc.without(join.leftKey)\n      }).run())\n    }\n    // nothing to do for \"belongsTo\"\n    else if (join.type === 'hasAndBelongsToMany') {\n      // Purge only if the key is a primary key\n      // What was called is joinedModel.hasAndBelongsToMany(self, fieldDoc, leftKey, rightKey)\n      if (self.getModel()._getModel()._pk === join.leftKey) {\n        promises.push(r.table(join.link).getAll(self[join.rightKey], {index: self.getModel().getTableName()+\"_\"+join.rightKey}).delete().run())\n      }\n    }\n  });\n\n  // Delete itself\n  promises.push(self.delete())\n\n  return new Promise(function(resolve, reject) {\n    Promise.all(promises).then(function() {\n      resolve(self);\n    }).error(reject);\n  }).nodeify(callback);\n}\n\nDocument.prototype.addRelation = function() {\n  var self = this;\n  var pk = self._getModel()._pk;\n\n  var query = self.getModel().get(this[pk])\n  return query.addRelation.apply(query, arguments);\n}\n\nDocument.prototype.removeRelation = function() {\n  var self = this;\n  var pk = self._getModel()._pk;\n\n  var query = self.getModel().get(this[pk])\n  return query.removeRelation.apply(query, arguments);\n}\n\n/**\n * Perform a `merge` of `obj` in this document. Extra keys will be removed.\n */\nDocument.prototype._merge = function(obj) {\n  var self = this;\n  util.loopKeys(self, function(self, key) {\n    if ((obj[key] === undefined) && (self._getModel()._joins[key] === undefined)) {\n      delete self[key];\n    }\n  });\n  util.loopKeys(obj, function(obj, key) {\n    self[key] = obj[key];\n  });\n  return self;\n}\n\n\n/**\n * Perform a `merge` of `obj` in this document. Extra keys will not be removed.\n */\nDocument.prototype.merge = function(obj) {\n  var self = this;\n  util.loopKeys(obj, function(obj, key) {\n    // Recursively merge only if both fields are objects, else we'll overwrite the field\n    if (util.isPlainObject(obj[key]) && util.isPlainObject(self[key])) {\n      Document.prototype.merge.call(self[key], obj[key])\n    }\n    else {\n      self[key] = obj[key];\n    }\n  });\n  return self;\n}\n\n/**\n * Set the atom feed and update the document for each change\n */\nDocument.prototype._setFeed = function(feed) {\n  var self = this;\n\n  self.__proto__._feed = feed;\n  self.__proto__._active = true;\n  feed.each(function(err, change) {\n    if (err) {\n      self.__proto__._active = false;\n      self.emit('error', err);\n    }\n    else {\n      if (change.new_val === null) {\n        // Delete all the fields\n        self._merge({});\n        self._setOldValue(change.old_val);\n        self._setUnSaved();\n        self.emit('change', self);\n      }\n      else {\n        self._merge(change.new_val);\n        self._setOldValue(change.old_val);\n        self.setSaved();\n        self.emit('change', self);\n      }\n    }\n\n  });\n};\n\nDocument.prototype.getFeed = function() {\n  return this.__proto__._feed;\n}\n\nDocument.prototype.closeFeed = function() {\n  return this.__proto__._feed.close();\n}\n\n/**\n * Have the model emit 'retrieved' with the current document and\n * recurse to have all joined models do the same.\n */\nDocument.prototype._emitRetrieve = function() {\n  var self = this;\n  self.getModel().emit('retrieved', self);\n  util.loopKeys(self._getModel()._joins, function(joins, key) {\n    var join = joins[key];\n    if ((joins[key].type === 'hasOne') || (joins[key].type === 'belongsTo')) {\n      if ((self[key] != null) && (typeof self[key]._emitRetrieve === 'function')) {\n        self[key]._emitRetrieve();\n      }\n    }\n    else if ((joins[key].type === 'hasMany') || (joins[key].type === 'hasAndBelongsToMany')) {\n      if (Array.isArray(self[key])) {\n        for(var i=0; i<self[key].length; i++) {\n          if (typeof self[key][i]._emitRetrieve === 'function') {\n            self[key][i]._emitRetrieve();\n          }\n        }\n      }\n    }\n  })\n}\n\nmodule.exports = Document;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/query.js":"var Promise = require('bluebird');\nvar util = require(__dirname+'/util.js');\nvar Errors = require(__dirname+'/errors.js');\nvar schemaUtil = require(__dirname+'/schema.js');\nvar Feed = require(__dirname+'/feed.js');\n\n\n/**\n * Constructor for a Query. A Query basically wraps a ReQL queries to keep track\n * of the model returned and if a post-query validation is required.\n * @param {Function=} model Model of the documents returned\n * @param {ReQLQuery=} current ReQL query (rethinkdbdash)\n * @param {boolean=} postValidation whether post query validation should be performed\n */\nfunction Query(model, query, options, error) {\n  var self = this;\n\n  this._model = model; // constructor of the model we should use for the results.\n  if (model !== undefined) {\n    this._r = model._getModel()._thinky.r;\n    util.loopKeys(model._getModel()._staticMethods, function(staticMethods, key) {\n      (function(_key) {\n        self[_key] = function() {\n          return staticMethods[_key].apply(self, arguments);\n        };\n      })(key);\n    });\n  }\n\n  if (query !== undefined) {\n    this._query = query;\n   }\n  else if (model !== undefined) {\n    // By default, we initialize the query to `r.table(<tableName>)`.\n    this._query = this._r.table(model.getTableName());\n  }\n\n  if (util.isPlainObject(options)) {\n    if (options.postValidation) {\n      this._postValidation = options.postValidation === true;\n    }\n    if (options.ungroup) {\n      this._ungroup = options.ungroup === true;\n    }\n    else {\n      this._ungroup = false;\n    }\n  }\n  else { // let the user rework the result after ungroup\n    this._ungroup = false;\n  }\n  if (error) {\n    // Note `Query.prototype.error` is defined because of `r.error`, so we shouldn't\n    // defined this.error.\n    this._error = error;\n  }\n  this._pointWrite = false;\n}\n\nQuery.prototype.setPostValidation = function() {\n  this._postValidation = true;\n}\n\nQuery.prototype.setPointWrite = function() {\n  this._pointWrite = true;\n}\n\n/**\n * Execute a Query and expect the results to be object(s) that can be converted\n * to instances of the model.\n * @param {Object=} options The options passed to the driver's method `run`\n * @param {Function=} callback\n * @return {Promise} return a promise that will be resolved when the query and\n * the instances of the models will be created (include the potential\n * asynchronous hooks).\n */\nQuery.prototype.run = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._execute(options, true).nodeify(callback);\n}\n\n\n/**\n * Execute a Query\n * @param {Object=} options The options passed to the driver's method `run`\n * @param {Function=} callback\n * @return {Promise} return a promise that will be resolved with the results\n * of the query.\n */\nQuery.prototype.execute = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._execute(options, false).nodeify(callback);\n}\n\n/**\n* Bind Query.prototype.run() for later use\n* @param {Object=} options The options passed to the driver's method `run`\n* @param {Function=} callback\n* @return {Function} return a `this` bound Query.prototype.run()\n*/\n\nQuery.prototype.bindRun = function () {\n  var curriedArgs = Array.prototype.slice.call(arguments);\n  return Function.prototype.bind.apply( Query.prototype.run, [ this ].concat( curriedArgs ) );\n}\n\n/**\n * Bind Query.prototype.execute() for later use\n * @param {Object=} options The options passed to the driver's method `run`\n * @param {Function=} callback\n * @return {Function} return a `this` bound Query.prototype.execute()\n */\n\nQuery.prototype.bindExecute = function () {\n  var curriedArgs = Array.prototype.slice.call(arguments);\n  return Function.prototype.bind.apply( Query.prototype.execute, [ this ].concat( curriedArgs ) );\n}\n\n/**\n * Internal method to execute a query. Called by `run` and `execute`.\n * @param {Object} options The options passed to the driver's method `run`\n * @param {boolean} parse Whether the results should be converted as instance(s) of the model\n * @param {Function=} callback\n * @return {Promise} return a promise that will be resolved with the results\n * of the query.\n * @private\n */\nQuery.prototype._execute = function(options, parse) {\n  var self = this;\n  options = options || {};\n  var fullOptions = {groupFormat: 'raw'}\n  util.loopKeys(options, function(options, key) {\n    fullOptions[key] = options[key]\n  });\n  if (parse === true) {\n    fullOptions.cursor = false;\n  }\n\n  if (self._model._error !== null) {\n    return Promise.reject(self._model._error);\n  }\n  return self._model.ready().then(function() {\n    return self._executeCallback(fullOptions, parse, options.groupFormat);\n  });\n}\n\nQuery.prototype._executeCallback = function(fullOptions, parse, groupFormat) {\n  var self = this;\n  if (self._error !== undefined) {\n    return Promise.reject(new Error(\"The partial value is not valid, so the write was not executed. The original error was:\\n\"+self._error.message));\n  }\n\n  return self._query.run(fullOptions).then(function(result) {\n    if (result === null && parse) {\n      throw new Errors.DocumentNotFound();\n    }\n\n    // Expect a write result from RethinkDB\n    if (self._postValidation === true) {\n      return self._validateQueryResult(result);\n    }\n\n    if (result != null && typeof result.getType === 'function') {\n      var resultType = result.getType();\n      if (resultType === 'Feed' ||\n        resultType === 'OrderByLimitFeed' ||\n        resultType === 'UnionedFeed'\n      ) {\n        var feed = new Feed(result, self._model);\n        return feed;\n      }\n\n      if (resultType === 'AtomFeed') {\n        return result.next().then(function(initial) {\n          var value = initial.new_val || {};\n          return self._model._parse(value).then(function(doc) {\n            doc._setFeed(result);\n            return doc;\n          });\n        });\n      }\n    }\n\n    if (parse === true) {\n      return self._model._parse(result, self._ungroup);\n    }\n\n    if (groupFormat !== 'raw') {\n      return Query.prototype._convertGroupedData(result);\n    }\n\n    return result;\n  }).catch(function(err) {\n    return Promise.reject(Errors.create(err));\n  })\n};\n\nQuery.prototype._validateUngroupResult = function(result) {\n}\n\nQuery.prototype._validateQueryResult = function(result) {\n  var self = this;\n  if (result.errors > 0) {\n    console.log(result);\n    return Promise.reject(new Errors.InvalidWrite(\"An error occured during the write\", result));\n  }\n  if (!Array.isArray(result.changes)) {\n    if (self._isPointWrite()) {\n      return Promise.resolve();\n    }\n    return Promise.resolve([]);\n  }\n\n  var promises = [];\n  for(var i=0; i<result.changes.length; i++) {\n    (function(i) {\n      if (result.changes[i].new_val !== null) {\n        promises.push(self._model._parse(result.changes[i].new_val));\n      }\n    })(i)\n  }\n  return Promise.all(promises).then(function(result) {\n    if (self._isPointWrite()) {\n      if (result.length > 1) {\n        throw new Error('A point write returned multiple values')\n      }\n      return result[0];\n    }\n    return result;\n  }).catch(function(error) {\n    if (error instanceof Errors.DocumentNotFound) {\n      // Should we send back null?\n    }\n    else {\n      var revertPromises = [];\n      var primaryKeys = [];\n      var keysToValues = {};\n      var r = self._model._thinky.r;\n      for(var p=0; p<result.changes.length; p++) {\n        // Extract the primary key of the document saved in the database\n        var primaryKey = util.extractPrimaryKey(\n            result.changes[p].old_val,\n            result.changes[p].new_val,\n            self._model._pk)\n        if (primaryKey === undefined) {\n          continue;\n        }\n\n        if (typeof primaryKey === \"string\") {\n          keysToValues[primaryKey] = result.changes[p].old_val;\n          primaryKeys.push(primaryKey);\n        }\n        else {\n          // Replace documents with non-string type primary keys\n          // one by one.\n          revertPromises.push(r.table(self._model.getTableName())\n            .get(primaryKey)\n            .replace(result.changes[p].old_val)\n            .run());\n        }\n      }\n\n      // Replace all documents with string-type primary keys\n      // in a single replace() operation.\n      if (primaryKeys.length) {\n        revertPromises.push(\n          r.table(self._model.getTableName()).getAll(r.args(primaryKeys)).replace(function(doc) {\n            return r.expr(keysToValues)(doc(self._model._pk));\n          }).run()\n        );\n      }\n\n      return Promise.all(revertPromises).then(function(result) {\n        throw new Error(\"The write failed, and the changes were reverted.\");\n      }).error(function(error) {\n        throw new Error(\"The write failed, and the attempt to revert the changes failed with the error:\\n\"+error.message);\n      });\n    }\n  })\n};\n\n\n/**\n * Convert GROUPED_DATA results to [group: <group>, reduction: <reduction>]\n * This does the same as the driver. The reduction is not converted to\n * instances of the model.\n */\nQuery.prototype._convertGroupedData = function(data) {\n  if (util.isPlainObject(data) && (data.$reql_type$ === \"GROUPED_DATA\")) {\n    var result = [];\n    var reduction;\n    for(var i=0; i<data.data.length; i++) {\n      result.push({\n        group: data.data[i][0],\n        reduction: data.data[i][1]\n      });\n    }\n    return result;\n  }\n  else {\n    return data;\n  }\n}\n\n\n/**\n * Perform a join given the relations on this._model\n * @param {Object=} modelToGet explicit joined documents to retrieve\n * @param {boolean} getAll Internal argument, if `modelToGet` is undefined, `getAll` will\n * be set to `true` and `getJoin` will be greedy and keep recursing as long as it does not\n * hit a circular reference\n * @param {Object=} gotModel Internal argument, the model we are already fetching.\n * @return {Query}\n */\nQuery.prototype.getJoin = function(modelToGet, getAll, gotModel) {\n  var self = this;\n  var r = self._model._getModel()._thinky.r;\n\n  var model = this._model;\n  var joins = this._model._getModel()._joins;\n\n  var getAll = modelToGet === undefined;\n  if (util.isPlainObject(modelToGet) === false) {\n    modelToGet = {};\n  }\n  var innerQuery;\n\n  gotModel = gotModel || {};\n  gotModel[model.getTableName()] = true;\n\n  util.loopKeys(joins, function(joins, key) {\n    if (util.recurse(key, joins, modelToGet, getAll, gotModel)) {\n      switch (joins[key].type) {\n        case 'hasOne':\n        case 'belongsTo':\n          self._query = self._query.merge(function(doc) {\n            return r.branch(\n              doc.hasFields(joins[key].leftKey),\n              r.table(joins[key].model.getTableName()).getAll(doc(joins[key].leftKey), {index: joins[key].rightKey}).coerceTo(\"ARRAY\").do(function(result) {\n                innerQuery = new Query(joins[key].model, result.nth(0));\n\n                if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {\n                  innerQuery = modelToGet[key]._apply(innerQuery);\n                }\n                innerQuery = innerQuery.getJoin(modelToGet[key], getAll, gotModel)._query;\n                return r.branch(\n                  result.count().eq(1),\n                  r.object(key, innerQuery),\n                  r.branch(\n                    result.count().eq(0),\n                    {},\n                    r.error(r.expr(\"More than one element found for \").add(doc.coerceTo(\"STRING\")).add(r.expr(\"for the field \").add(key)))\n                  )\n                )\n              }),\n              {}\n            )\n          });\n          break;\n\n        case 'hasMany':\n          self._query = self._query.merge(function(doc) {\n            innerQuery = new Query(joins[key].model,\n                       r.table(joins[key].model.getTableName())\n                      .getAll(doc(joins[key].leftKey), {index: joins[key].rightKey}))\n\n            if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {\n              innerQuery = modelToGet[key]._apply(innerQuery);\n            }\n            innerQuery = innerQuery.getJoin(modelToGet[key], getAll, gotModel);\n            if ((modelToGet[key] == null) || (modelToGet[key]._array !== false)) {\n              innerQuery = innerQuery.coerceTo(\"ARRAY\");\n            }\n            innerQuery = innerQuery._query;\n\n            return r.branch(\n              doc.hasFields(joins[key].leftKey),\n              r.object(key, innerQuery),\n              {}\n            )\n          });\n          break;\n\n        case 'hasAndBelongsToMany':\n          self._query = self._query.merge(function(doc) {\n            if ((model.getTableName() === joins[key].model.getTableName()) && (joins[key].leftKey === joins[key].rightKey)) {\n              // In case the model is linked with itself on the same key\n\n              innerQuery = r.table(joins[key].link).getAll(doc(joins[key].leftKey), {index: joins[key].leftKey+\"_\"+joins[key].leftKey}).concatMap(function(link) {\n                return r.table(joins[key].model.getTableName()).getAll(\n                  r.branch(\n                    doc(joins[key].leftKey).eq(link(joins[key].leftKey+\"_\"+joins[key].leftKey).nth(0)),\n                    link(joins[key].leftKey+\"_\"+joins[key].leftKey).nth(1),\n                    link(joins[key].leftKey+\"_\"+joins[key].leftKey).nth(0)\n                  )\n                , {index: joins[key].rightKey})\n              });\n\n              if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {\n                innerQuery = modelToGet[key]._apply(innerQuery);\n              }\n\n              if ((modelToGet[key] == null) || (modelToGet[key]._array !== false)) {\n                innerQuery = innerQuery.coerceTo(\"ARRAY\");\n              }\n\n              return r.branch(\n                doc.hasFields(joins[key].leftKey),\n                r.object(key, new Query(joins[key].model, innerQuery).getJoin(modelToGet[key], getAll, gotModel)._query),\n                {}\n              )\n            }\n            else {\n              innerQuery = r.table(joins[key].link).getAll(doc(joins[key].leftKey), {index: model.getTableName()+\"_\"+joins[key].leftKey}).concatMap(function(link) {\n                return r.table(joins[key].model.getTableName()).getAll(link(joins[key].model.getTableName()+\"_\"+joins[key].rightKey), {index: joins[key].rightKey})\n              });\n\n              if ((modelToGet[key] != null) && (typeof modelToGet[key]._apply === 'function')) {\n                innerQuery = modelToGet[key]._apply(innerQuery)\n              }\n\n              if ((modelToGet[key] == null) || (modelToGet[key]._array !== false)) {\n                innerQuery = innerQuery.coerceTo(\"ARRAY\");\n              }\n\n              return r.branch(\n                doc.hasFields(joins[key].leftKey),\n                r.object(key,\n                  new Query(joins[key].model, innerQuery).getJoin(modelToGet[key], getAll, gotModel)._query),\n                {}\n              )\n            }\n          });\n          break;\n      }\n    }\n  });\n\n  return self;\n};\n\n\n/**\n * Add a relation\n * @param {string} field The field of the joined document(s)\n * @param {Object} joinedDocument An object with the primary key defined or the related key\n * @return {Promise}\n *\n * hasOne, primary key required\n * User.get(1).addRelation(\"account\", {id: 2, sold: 2132})\n * The promise resolved the document on which addRelation is called\n *\n * hasMany, primary key required\n * User.get(1).addRelation(\"accounts\", {id: 2, sold: 2132})\n * The promise resolved the updated joined document\n *\n * belongsTo, right joined key OR primary key required\n * User.get(1).addRelation(\"account\", {id: 2, sold: 2132})\n * The promise resolved the document on which addRelation is called\n *\n * hasAndBelongsToMany, right joined key required\n * User.get(1).addRelation(\"accounts\", {id: 2, sold: 2132})\n * The promise resolved with true\n */\n\nQuery.prototype.addRelation = function(field, joinedDocument) {\n  var self = this;\n  var model = self._model;\n  var joins = self._model._getModel()._joins;\n  var joinedModel = joins[field].model;\n  var r = self._model._thinky.r;\n\n  switch (joins[field].type) {\n    case 'hasOne':\n    case 'hasMany':\n      if (joinedDocument[joinedModel._pk] === undefined) {\n        return new Query(model, self, {},\n            new Error('Primary key for the joined document not found for a `hasOne/hasMany` relation.')\n        );\n      }\n      var updateValue = {};\n      updateValue[joins[field].rightKey] = self._query(joins[field].leftKey);\n      return joinedModel.get(joinedDocument[joinedModel._pk]).update(updateValue, {nonAtomic: true}).run()\n    case 'belongsTo':\n      var updateValue = {};\n      if (joinedDocument[joins[field].rightKey] === undefined) {\n        if (joinedDocument[joinedModel._pk] === undefined) {\n          return new Query(model, self, {},\n              new Error('The primary key or the joined key must be defined in the joined document for a `belongsTo` relation.')\n          );\n        }\n        updateValue[joins[field].leftKey] = joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey)._query;\n      }\n      else {\n        updateValue[joins[field].leftKey] = joinedDocument[joins[field].rightKey];\n      }\n      return self.update(updateValue, {nonAtomic: true}).run();\n    case 'hasAndBelongsToMany':\n      var linkModel = joins[field].linkModel;\n      var linkValue;\n      var link;\n      if (joinedDocument[joins[field].rightKey] === undefined) {\n        if (joinedDocument[joinedModel._pk] === undefined) {\n          return new Query(model, self, {},\n              new Error('The primary key or the joined key must be defined in the joined document for a `hasAndBelongsToMany` relation.')\n          );\n        }\n        link = joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey)._query\n      }\n      else {\n        link = r.expr(joinedDocument[joins[field].rightKey]);\n      }\n\n      if ((model.getTableName() === joinedModel.getTableName())\n          && (joins[field].leftKey === joins[field].rightKey)) {\n        linkValue = self._query(joins[field].leftKey).do(function(leftKey) {\n          return link.do(function(rightKey) {\n            return r.branch(\n                rightKey.lt(leftKey),\n                r.object(\n                  'id', rightKey.add('_').add(leftKey),\n                  joins[field].leftKey+\"_\"+joins[field].leftKey, [leftKey, rightKey]\n                ),\n                r.object(\n                  'id', leftKey.add('_').add(rightKey),\n                  joins[field].leftKey+\"_\"+joins[field].leftKey, [leftKey, rightKey]\n                )\n            )\n          });\n        });\n      }\n      else {\n        linkValue = self._query(joins[field].leftKey).do(function(leftKey) {\n          return link.do(function(rightKey) {\n            if (model.getTableName() < joinedModel.getTableName()) {\n              return r.object(\n                'id', leftKey.add('_').add(rightKey),\n                model.getTableName()+\"_\"+joins[field].leftKey, leftKey,\n                joinedModel.getTableName()+\"_\"+joins[field].rightKey,rightKey \n              )\n            }\n            else if (model.getTableName() > joinedModel.getTableName()) {\n              return r.object(\n                'id', rightKey.add('_').add(leftKey),\n                model.getTableName()+\"_\"+joins[field].leftKey, leftKey,\n                joinedModel.getTableName()+\"_\"+joins[field].rightKey,rightKey \n              )\n            }\n            else {\n              return r.branch(\n                rightKey.lt(leftKey),\n                r.object(\n                  'id', leftKey.add('_').add(rightKey),\n                  model.getTableName()+\"_\"+joins[field].leftKey, leftKey,\n                  joinedModel.getTableName()+\"_\"+joins[field].rightKey,rightKey \n                ),\n                r.object(\n                  'id', rightKey.add('_').add(leftKey),\n                  model.getTableName()+\"_\"+joins[field].leftKey, leftKey,\n                  joinedModel.getTableName()+\"_\"+joins[field].rightKey,rightKey \n                )\n              )\n            }\n          });\n        });\n      }\n\n      return linkModel.insert(linkValue, {conflict: \"replace\", returnChanges: 'always'}).do(function(result) {\n        return r.branch(\n            result('errors').eq(0),\n            true, // not relevant value\n            r.error(result('errors'))\n        )\n      }).execute()\n    default:\n      return new Query(model, self, {},\n          new Error('The provided field `'+field+'` does not store joined documents.')\n      ).run()\n  }\n}\n\n/**\n * Remove the provided relation\n * @param {string} field The field of the joined document(s) to remove\n * @param {Array} joinedDocument The document with who the relation should be removed\n * @return {Promise}\n */\n//TODO Support an array of joinedDocuments?\nQuery.prototype.removeRelation = function(field, joinedDocument) {\n  var self = this;\n  var model = self._model;\n  var joins = self._model._getModel()._joins;\n  var joinedModel = joins[field].model;\n  var r = self._model._thinky.r;\n\n  var query;\n  switch (joins[field].type) {\n    case 'hasOne':\n      query = joinedModel.getAll(self._query(joins[field].leftKey), {index: joins[field].rightKey}).replace(function(row) {\n        return row.without(joins[field].rightKey)\n      });\n      query.setPostValidation();\n      query.setPointWrite();\n      return query;\n    case 'hasMany':\n      if (joinedDocument === undefined) {\n        query = joinedModel.getAll(self._query(joins[field].leftKey), {index: joins[field].rightKey}).replace(function(row) {\n          return row.without(joins[field].rightKey)\n        })\n      }\n      else {\n        query = joinedModel.getAll(r.expr(joinedDocument)(joinedModel._pk)).replace(function(row) {\n          return row.without(joins[field].rightKey)\n        })\n      }\n      query.setPostValidation();\n      return query;\n    case 'belongsTo':\n      query = self.replace(function(row) {\n        return row.without(joins[field].leftKey)\n      })\n      query.setPostValidation();\n      return query;\n    case 'hasAndBelongsToMany':\n      var linkModel = joins[field].linkModel;\n      if (joinedDocument === undefined) {\n        query = self._query(joins[field].leftKey).do(function(leftKey) {\n          // range are not supported at the moment, so keys is an object and we don't have to worry about empty sequences\n          if ((model.getTableName() === joinedModel.getTableName())\n              && (joins[field].leftKey === joins[field].rightKey)) {\n            return linkModel.getAll(leftKey, {index: joins[field].leftKey+'_'+joins[field].leftKey}).delete()._query\n          }\n          else {\n            return linkModel.getAll(leftKey, {index: model.getTableName()+'_'+joins[field].leftKey}).delete()._query\n          }\n        }).do(function(result) {\n          return r.branch(\n              result('errors').eq(0),\n              true, // not relevant value\n              r.error(result('errors'))\n           )\n        })\n      }\n      else {\n        if (joinedDocument[joins[field].rightKey] === undefined) {\n          if (joinedDocument[joinedModel._pk] === undefined) {\n            return new Query(model, self, {},\n                new Error('The primary key or the joined key must be defined in the joined document for a `hasAndBelongsToMany` relation.')\n            );\n          }\n\n          if ((model.getTableName() === joinedModel.getTableName())\n              && (joins[field].leftKey === joins[field].rightKey)) {\n            query = self._query(joins[field].leftKey).do(function(leftKey) {\n              return joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey).do(function(rightKey) {\n                if (model.getTableName() < joinedModel.getTableName()) {\n                  return linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query;\n                }\n                else if (model.getTableName() > joinedModel.getTableName()) {\n                  return linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query;\n                }\n                else {\n                  return r.branch(\n                    leftKey.lt(rightKey),\n                    linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query,\n                    linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query\n                  )\n                }\n              });\n            })\n          }\n          else {\n            query = self._query(joins[field].leftKey).do(function(leftKey) {\n              return joinedModel.get(joinedDocument[joinedModel._pk]).bracket(joins[field].rightKey).do(function(rightKey) {\n                if (model.getTableName() < joinedModel.getTableName()) {\n                  return linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query\n                }\n                else if (model.getTableName() > joinedModel.getTableName()) {\n                  return linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query\n                }\n                else {\n                  return r.branch(\n                    leftKey.lt(rightKey),\n                    linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query,\n                    linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query\n                  )\n\n                }\n              });\n            })\n          }\n        }\n        else {\n          query = self._query(joins[field].leftKey).do(function(leftKey) {\n            var rightKey = r.expr(joinedDocument[joins[field].rightKey]);\n            if (model.getTableName() < joinedModel.getTableName()) {\n              return linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query\n            }\n            else if (model.getTableName() > joinedModel.getTableName()) {\n              return linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query\n            }\n            else {\n              return r.branch(\n                leftKey.lt(rightKey),\n                linkModel.getAll(leftKey.add('_').add(rightKey)).delete()._query,\n                linkModel.getAll(rightKey.add('_').add(leftKey)).delete()._query\n              )\n\n            }\n          })\n        }\n      }\n      return query;\n    default:\n      return new Query(model, self, {},\n          new Error('The provided field `'+field+'` does not store joined documents.')\n      );\n  }\n};\n\n/**\n * Import all the methods from rethinkdbdash, expect the private one (the one\n * starting with an underscore).\n * Some method are slightly changed: `get`, `update`, `replace`.\n */\n(function() {\n  var Term = require('rethinkdbdash')({pool: false}).expr(1).__proto__;\n  util.loopKeys(Term, function(Term, key) {\n    if (key === 'run' || key[0] === '_') return;\n    // Note: We suppose that no method has an empty name\n    switch (key) {\n      case 'get':\n        // `get` in thinky returns an error if the document is not found.\n        // The driver currently just returns `null`.\n        (function(key) {\n          Query.prototype[key] = function() {\n            return new Query(this._model, this._query[key].apply(this._query, arguments)).default(this._r.error(new Errors.DocumentNotFound().message));\n          }\n        })(key);\n        // Copy it in `_get` without `default`.\n        (function(key) {\n          Query.prototype['_get'] = function() {\n            // Create a new query to let people fork it\n            return new Query(this._model, this._query[key].apply(this._query, arguments));\n          }\n        })(key);\n        break;\n      case 'update':\n      case 'replace':\n        // `update` and `replace` can be used. A partial validation is performed before\n        // sending the query, and a full validation is performed after the query. If the\n        // validation fails, the document(s) will be reverted.\n        (function(key) {\n          Query.prototype[key] = function(value, options) {\n            options = options || {};\n            options.returnChanges = 'always';\n            var error = null;\n            var self = this;\n            util.tryCatch(function() {\n              if (util.isPlainObject(value)) {\n                schemaUtil.validate(value, self._model._schema, '', {enforce_missing: false});\n              }\n            }, function(err) {\n              error = err;\n            });\n            return new Query(this._model, this._query[key].call(this._query, value, options), {postValidation: true}, error);\n          }\n        })(key);\n        break;\n\n      case 'changes':\n        (function(key) {\n          Query.prototype[key] = function() {\n            // In case of `get().changes()` we want to remove the default(r.errror(...))\n            // TODO: Do not hardcode this?\n            if ((typeof this._query === 'function') && (this._query._query[0] === 92)) {\n              this._query._query = this._query._query[1][0];\n            }\n            return new Query(this._model, this._query[key].apply(this._query, arguments));\n          }\n        })(key);\n        break;\n\n      case 'then':\n      case 'error':\n      case 'catch':\n      case 'finally':\n        (function(key) {\n          Query.prototype[key] = function() {\n            var promise = this.run();\n            return promise[key].apply(promise, arguments);\n          }\n        })(key);\n        break;\n\n      case 'ungroup':\n        (function(key) {\n          Query.prototype[key] = function() {\n            return new Query(this._model, this._query[key].apply(this._query, arguments), {ungroup: true});\n          }\n        })(key);\n        break;\n\n      default:\n        (function(key) {\n          Query.prototype[key] = function() {\n            // Create a new query to let people fork it\n            return new Query(this._model, this._query[key].apply(this._query, arguments));\n          }\n        })(key);\n        break;\n      }\n  });\n})();\n\nQuery.prototype._isPointWrite = function() {\n  return this._pointWrite || (Array.isArray(this._query._query) &&\n      (this._query._query.length > 1) &&\n      Array.isArray(this._query._query[1]) &&\n      (this._query._query[1].length > 0) &&\n      Array.isArray(this._query._query[1][0]) &&\n      (this._query._query[1][0].length > 1) &&\n      Array.isArray(this._query._query[1][0][1]) &&\n      (this._query._query[1][0][1].length > 0) &&\n      Array.isArray(this._query._query[1][0][1][0]) &&\n      (this._query._query[1][0][1][0][0] === 16))\n}\n\n/**\n * Convert the query to its string representation.\n * @return {string}\n */\nQuery.prototype.toString = function() {\n  return this._query.toString();\n}\n\nmodule.exports = Query;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/lib/feed.js":"var Promise = require('bluebird');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require(__dirname+'/util.js');\n\nfunction Feed(feed, model) {\n  this.feed = feed;\n  this.model = model;\n  this._closed = false;\n\n  this.each = this._each;\n  this.next = this._next;\n}\n\nFeed.prototype.toString = function() {\n  return '[object Feed]'\n}\n\n\nFeed.prototype._next = function() {\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    self.feed.next().then(function(data) {\n      util.tryCatch(function() {\n        if (data.new_val != null) {\n          self.model._parse(data.new_val).then(function(doc) {\n            doc._setOldValue(data.old_val);\n            resolve(doc);\n          }).error(reject);\n        }\n        else if (data.old_val != null) { // new_val is null\n          self.model._parse(data.old_val).then(function(doc) {\n            doc._setUnSaved();\n            resolve(doc);\n          }).error(reject);\n        }\n        //else we just drop the change as it's a state/initializing object\n      }, function(err) {\n        reject(err);\n      })\n    }).error(reject);\n  });\n}\n\nFeed.prototype.toArray = function() {\n  throw new Error(\"The `toArray` method is not available on feeds.\");\n}\n\nFeed.prototype.close = function(callback) {\n  this._closed = true;\n  return this.feed.close(callback);\n}\n\nFeed.prototype._each = function(callback, onFinish) {\n  var self = this;\n  self.feed.each(function(err, data) {\n    if (err) {\n      if (self._closed === true) {\n        return;\n      }\n      return callback(err);\n    }\n    util.tryCatch(function() {\n      if (data.new_val != null) {\n        self.model._parse(data.new_val).then(function(doc) {\n          doc._setOldValue(data.old_val);\n          callback(null, doc);\n        }).error(function(err) {\n          callback(err);\n        });\n      }\n      else if (data.old_val != null) { // new_val is null\n        self.model._parse(data.old_val).then(function(doc) {\n          doc._setUnSaved();\n          callback(null, doc);\n        }).error(function(err) {\n          callback(err);\n        });\n      }\n      //else we just drop the change as it's a state/initializing object\n    }, function(err) {\n      callback(err);\n    })\n  }, onFinish);\n};\n\nFeed.prototype._makeEmitter = function() {\n  this.next = function() {\n    throw new Error(\"You cannot called `next` once you have bound listeners on the feed\")\n  }\n  this.each = function() {\n    throw new Error(\"You cannot called `each` once you have bound listeners on the feed\")\n  }\n  this.toArray = function() {\n    throw new Error(\"You cannot called `toArray` once you have bound listeners on the feed\")\n  }\n  this._eventEmitter = new EventEmitter();\n}\n\nFeed.prototype._eachCb = function(err, data) {\n  var self = this;\n  if (err != null) {\n    if ((this._closed !== false) || (err.message !== \"You cannot retrieve data from a cursor that is closed\")) {\n      self._eventEmitter.emit('error', err);\n    }\n    return;\n  }\n\n  util.tryCatch(function() {\n    if (data.new_val !== null) {\n      self.model._parse(data.new_val).then(function(doc) {\n        doc._setOldValue(data.old_val);\n        self._eventEmitter.emit('data', doc);\n      }).error(function(err) {\n        self._eventEmitter.emit('error', err);\n      });\n    }\n    else if (data.old_val !== null) { // new_val is null\n      self.model._parse(data.old_val).then(function(doc) {\n        doc._setUnSaved();\n        self._eventEmitter.emit('data', doc);\n      }).error(function(err) {\n        self._eventEmitter.emit('error', err);\n      });\n    }\n  }, function(err) {\n    self._eventEmitter.emit('error', err);\n  })\n}\n\nvar methods = [\n    'addListener',\n    'on',\n    'once',\n    'removeListener',\n    'removeAllListeners',\n    'setMaxListeners',\n    'listeners',\n    'emit'\n];\n\nfor(var i=0; i<methods.length; i++) {\n  (function(n) {\n    var method = methods[n];\n    Feed.prototype[method] = function() {\n      var self = this;\n      if (self._eventEmitter == null) {\n        self._makeEmitter();\n        setImmediate(function() {\n          self.feed._each(self._eachCb.bind(self), function() {\n            self._eventEmitter.emit('end');\n          });\n        });\n      }\n      self._eventEmitter[method].apply(self._eventEmitter, util.toArray(arguments));\n    };\n  })(i);\n}\n\nmodule.exports = Feed;\n","/home/travis/build/npmtest/node-npmtest-thinky/node_modules/thinky/config.js":"exports.host = process.env['WERCKER_RETHINKDB_HOST'] || 'localhost';\nexports.port = process.env['WERCKER_RETHINKDB_PORT'] || 28015;\nexports.db = 'thinky_test';\nexports.authKey = '';\n"}